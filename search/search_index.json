{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Materials Project Workshop 2020 (July 28 - 30) \u00b6 The Materials Project Workshop is two-day interactive workshop to learn to use th Materials Project (MP) open-source tools. Topics will include basic structure manipulation, querying data from MP using the API, automating DFT calculations, exploring new chemical systems and machine learning. A optional one-day python and MongoDB primer is provided for anyone new to python programming and using databases. We'll also provide a virtual poster-session for anyone interested in networking with other participants. Registration \u00b6 Registration is currently closed. Location \u00b6 The 2020 Materials Project Workshop will be fully virtual due to COVID related travel and congregation restrictions. We'll use a cloud-based python environment to enable interactive tutorials where we provide close support. Primer (optional) \u00b6 All times are in Pacific Daylight Time. Tuesday Morning -- Python/Jupyter Primer \u00b6 09:00-09:20 Intro - Logistics 09:20-10:20 Basics - Variables, Lists, Loops 10:20-10:40 Break 10:40-11:40 Control: Conditions, Funtions, Sets/Dictionaries 11:40-12:00 Open Discussion 12:00-13:00 Lunch Tuesday Afternoon -- MongoDB using Python primer \u00b6 13:00-13:20 Data Modeling - Python Types to JSON to MongoDB 13:20-14:00 Listing, Counting, Finding, and Dot Notation 14:00-14:20 Break 14:20-15:20 Advanced Filtering, Basic Aggregation, and Indexing 15:20-15:40 Open Discussion 15:40-16:00 Wrap-Up Main Workshop \u00b6 All times are in Pacific Daylight Time. Wednesday Morning \u00b6 09:00-09:20 Overview of the Materials Project 09:20-10:20 Using the Website Effectively 10:20-10:40 Break 10:40-11:40 Pymatgen Foundations 11:40-12:00 Open Discussion 12:00-13:00 Lunch Wednesday Afternoon \u00b6 13:00-14:00 Working with Surfaces in Pymatgen 14:00-14:20 Break 14:20-15:20 Using the Materials API 15:20-15:40 Open Discussion 15:40-16:00 Wrap-up Thursday Morning \u00b6 09:00-09:20 Intro 09:20-10:20 Automating DFT 10:20-10:40 Break 10:40-11:40 Exploring New Systems with Pymatgen 11:40-12:00 Open Discussion 12:00-13:00 Lunch Thursday Afternoon \u00b6 13:00-14:00 MPContribs : Share You Data via MPContribs 14:00-14:20 Break 14:20-15:40 Machine Learning with Matminer 15:40-16:00 Wrap-Up Still have questions? \u00b6 If you have any further questions, you can find some more helpful info and confact information here","title":"Home"},{"location":"#materials-project-workshop-2020-july-28-30","text":"The Materials Project Workshop is two-day interactive workshop to learn to use th Materials Project (MP) open-source tools. Topics will include basic structure manipulation, querying data from MP using the API, automating DFT calculations, exploring new chemical systems and machine learning. A optional one-day python and MongoDB primer is provided for anyone new to python programming and using databases. We'll also provide a virtual poster-session for anyone interested in networking with other participants.","title":"Materials Project Workshop 2020 (July 28 - 30)"},{"location":"#registration","text":"Registration is currently closed.","title":"Registration"},{"location":"#location","text":"The 2020 Materials Project Workshop will be fully virtual due to COVID related travel and congregation restrictions. We'll use a cloud-based python environment to enable interactive tutorials where we provide close support.","title":"Location"},{"location":"#primer-optional","text":"All times are in Pacific Daylight Time.","title":"Primer (optional)"},{"location":"#tuesday-morning-pythonjupyter-primer","text":"09:00-09:20 Intro - Logistics 09:20-10:20 Basics - Variables, Lists, Loops 10:20-10:40 Break 10:40-11:40 Control: Conditions, Funtions, Sets/Dictionaries 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Tuesday Morning -- Python/Jupyter Primer"},{"location":"#tuesday-afternoon-mongodb-using-python-primer","text":"13:00-13:20 Data Modeling - Python Types to JSON to MongoDB 13:20-14:00 Listing, Counting, Finding, and Dot Notation 14:00-14:20 Break 14:20-15:20 Advanced Filtering, Basic Aggregation, and Indexing 15:20-15:40 Open Discussion 15:40-16:00 Wrap-Up","title":"Tuesday Afternoon -- MongoDB using Python primer"},{"location":"#main-workshop","text":"All times are in Pacific Daylight Time.","title":"Main Workshop"},{"location":"#wednesday-morning","text":"09:00-09:20 Overview of the Materials Project 09:20-10:20 Using the Website Effectively 10:20-10:40 Break 10:40-11:40 Pymatgen Foundations 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Wednesday Morning"},{"location":"#wednesday-afternoon","text":"13:00-14:00 Working with Surfaces in Pymatgen 14:00-14:20 Break 14:20-15:20 Using the Materials API 15:20-15:40 Open Discussion 15:40-16:00 Wrap-up","title":"Wednesday Afternoon"},{"location":"#thursday-morning","text":"09:00-09:20 Intro 09:20-10:20 Automating DFT 10:20-10:40 Break 10:40-11:40 Exploring New Systems with Pymatgen 11:40-12:00 Open Discussion 12:00-13:00 Lunch","title":"Thursday Morning"},{"location":"#thursday-afternoon","text":"13:00-14:00 MPContribs : Share You Data via MPContribs 14:00-14:20 Break 14:20-15:40 Machine Learning with Matminer 15:40-16:00 Wrap-Up","title":"Thursday Afternoon"},{"location":"#still-have-questions","text":"If you have any further questions, you can find some more helpful info and confact information here","title":"Still have questions?"},{"location":"logistics/logistics/","text":"Logistics \u00b6 Before the Workshop \u00b6 Virtual Poster-Session \u00b6 We'll host a virtual poster-session via a YouTube video for lightning summaries and a FigShare repository with associated DOI for citation. Please email : your poster PDF a 1-minute lighting video explaining the main concept behind your poster. This shouldn't be detailed summary of your work, but rather a high-level description that everyone can listen to and then decide which posters they want to focus on such as an elevator-pitch. We'll host the lightning-videos on our YouTube Channel and publish the PDFs on FigShare with a DOI that everyone can cite for this poster session. Setup Instructions: \u00b6 Sign in to your MP account online. Register for an account first if needed. Sign in to an account on CoCalc using the same email address you registered with. This will be the online python service we'll use to work interactively. Finding your API Key: \u00b6 An important aspect of the Materials Project API is the use of API keys to ensure we can control the amount of traffic that comes to the API. Otherwise, it's very easy for someone to take down the MP servers, making them unavailable for anyone. Your API key can be accessed via the Dashboard: Login to your Materials Project account and find the dashboard in the top right hand corner Your API is displayed in the middle under the Generate API Key button. Keep this to yourself. You can reset your API key at any time. Finding your MPContribs API Key: \u00b6 Currently the API key for MPContribs is separate from Materials Project. In order to get your MPContribs API key. Login to portal.mpcontribs.org Hover over the More drop-down in the top right hand corner Click the API Key button to copy your API key to your clipboard. You can now paste this into your notebook during the MPContribs lesson. During the Workshop \u00b6 Start of the Day Instructions \u00b6 Sign in to CoCalc Sign in to the Zoom Link Sign in to the MP Workshop slack Lesson Format \u00b6 The lessons will be taught in 20-minute sessions as 10-minutes of lesson followed by 10-minutes of a hands-on exercise. You're welcome to follow along with the already filled in hand-out notebook or by typing in to an empty notebook as we go along in the lesson. If you need help \u00b6 Click the chat icon at the top right corner your CoCalc browser window. Type in a message in the new chat window followed by Shift + Enter to send the message and our helpers will be notified. If you have a General Question \u00b6 Feel free to ask a question in the MP Workshop Slack #workshop2020 channel","title":"Logistics"},{"location":"logistics/logistics/#logistics","text":"","title":"Logistics"},{"location":"logistics/logistics/#before-the-workshop","text":"","title":"Before the Workshop"},{"location":"logistics/logistics/#virtual-poster-session","text":"We'll host a virtual poster-session via a YouTube video for lightning summaries and a FigShare repository with associated DOI for citation. Please email : your poster PDF a 1-minute lighting video explaining the main concept behind your poster. This shouldn't be detailed summary of your work, but rather a high-level description that everyone can listen to and then decide which posters they want to focus on such as an elevator-pitch. We'll host the lightning-videos on our YouTube Channel and publish the PDFs on FigShare with a DOI that everyone can cite for this poster session.","title":"Virtual Poster-Session"},{"location":"logistics/logistics/#setup-instructions","text":"Sign in to your MP account online. Register for an account first if needed. Sign in to an account on CoCalc using the same email address you registered with. This will be the online python service we'll use to work interactively.","title":"Setup Instructions:"},{"location":"logistics/logistics/#finding-your-api-key","text":"An important aspect of the Materials Project API is the use of API keys to ensure we can control the amount of traffic that comes to the API. Otherwise, it's very easy for someone to take down the MP servers, making them unavailable for anyone. Your API key can be accessed via the Dashboard: Login to your Materials Project account and find the dashboard in the top right hand corner Your API is displayed in the middle under the Generate API Key button. Keep this to yourself. You can reset your API key at any time.","title":"Finding your API Key:"},{"location":"logistics/logistics/#finding-your-mpcontribs-api-key","text":"Currently the API key for MPContribs is separate from Materials Project. In order to get your MPContribs API key. Login to portal.mpcontribs.org Hover over the More drop-down in the top right hand corner Click the API Key button to copy your API key to your clipboard. You can now paste this into your notebook during the MPContribs lesson.","title":"Finding your MPContribs API Key:"},{"location":"logistics/logistics/#during-the-workshop","text":"","title":"During the Workshop"},{"location":"logistics/logistics/#start-of-the-day-instructions","text":"Sign in to CoCalc Sign in to the Zoom Link Sign in to the MP Workshop slack","title":"Start of the Day Instructions"},{"location":"logistics/logistics/#lesson-format","text":"The lessons will be taught in 20-minute sessions as 10-minutes of lesson followed by 10-minutes of a hands-on exercise. You're welcome to follow along with the already filled in hand-out notebook or by typing in to an empty notebook as we go along in the lesson.","title":"Lesson Format"},{"location":"logistics/logistics/#if-you-need-help","text":"Click the chat icon at the top right corner your CoCalc browser window. Type in a message in the new chat window followed by Shift + Enter to send the message and our helpers will be notified.","title":"If you need help"},{"location":"logistics/logistics/#if-you-have-a-general-question","text":"Feel free to ask a question in the MP Workshop Slack #workshop2020 channel","title":"If you have a General Question"},{"location":"people/people/","text":"People \u00b6 The annual MP Workshop would not be possible without all the people that contribute. In particular, several critical people step up each year to plan, organize, develop lessons, run the workshop, teach, collect post-workshop surveys, and begin planning again. This page highlights those individuals who have contributed significantly to this workshop each year. 2020 \u00b6 2020 is particularly important as the transition from an in-person 40-person workshop to an online 100-person workshop represents a significant effort. The workshop lesson plan changes a little bit each year, but these individuals stepped up and reworked the lessons for a virtual teaching environment. This represents 100's, if not well over 1000+ combined hours of effort. Organizers \u00b6 Shyam Dwaraknath Matthew Horton Patrick Huck Alice Muller Kristin Persson Instructors \u00b6 Ryan Kingbury Guy Moore Jason Munro Sam Blau Evan Spotte-Smith Oxana Andriuc John Dagdelen Rachel Woods-Robinson Alex Ganose Helpers \u00b6 Mingjian Wen Jianli Cheng Ann Rutt Hetal Patel Kara Fong Matt McDermott Jimmy Shen Eric Sivonxay","title":"People"},{"location":"people/people/#people","text":"The annual MP Workshop would not be possible without all the people that contribute. In particular, several critical people step up each year to plan, organize, develop lessons, run the workshop, teach, collect post-workshop surveys, and begin planning again. This page highlights those individuals who have contributed significantly to this workshop each year.","title":"People"},{"location":"people/people/#2020","text":"2020 is particularly important as the transition from an in-person 40-person workshop to an online 100-person workshop represents a significant effort. The workshop lesson plan changes a little bit each year, but these individuals stepped up and reworked the lessons for a virtual teaching environment. This represents 100's, if not well over 1000+ combined hours of effort.","title":"2020"},{"location":"people/people/#organizers","text":"Shyam Dwaraknath Matthew Horton Patrick Huck Alice Muller Kristin Persson","title":"Organizers"},{"location":"people/people/#instructors","text":"Ryan Kingbury Guy Moore Jason Munro Sam Blau Evan Spotte-Smith Oxana Andriuc John Dagdelen Rachel Woods-Robinson Alex Ganose","title":"Instructors"},{"location":"people/people/#helpers","text":"Mingjian Wen Jianli Cheng Ann Rutt Hetal Patel Kara Fong Matt McDermott Jimmy Shen Eric Sivonxay","title":"Helpers"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Introduction to Python and Using Jupyter notebooks \u00b6 The Jupyter notebook is a platform for using and writing code in a dynamic way that allows users to combine cells of code snippets that are executed with a persistent namespace and kernel alongside markdown text for facilitating readability and visualization. In this notebook, we cover some basics of Jupyter functionality along with a discussion of some details of how you can use python in this environment and elsewhere. Installation \u00b6 For this workshop, we've constructed an online environment for everyone to use in order to smooth out any platform-dependent installation issues, but you'll probably want to install the tools we use today locally on your own machine. To do this, we recommend Anaconda , which is an effective tool for python package management that can create virtual environments, comes with a pre-installed IDE, and includes all of the Jupyter functionality that you'll see here. The Anaconda installer should be detailed on the page linked above, but here's another resource for installation that might be helpful. Code vs. Markdown \u00b6 Jupyter notebooks are broken down into \"cells\" which might contain either code or markdown. If you select a cell with your mouse, it should be highlighted with a green border indicating that you are in \"edit,\" mode and can edit the contents of the cell. If text reading In [ ]: is on the left hand side of the cell, it's a \"code\" cell. For example, type the following and press \"Shift + Enter\" print ( \"Hello world!\" ) Hello world! Pressing \"Shift + Enter\" executes the code in the cell, prints the output below the cell, and creates a new cell below that one. In addition to code cells, you can also write your own markdown cells by converting a cell using either the dropdown menu in the toolbar or pressing \"Esc + m\". In general, pressing escape enters \"command mode\" for which you can issue a number of commands, including f - find and replace m - convert to markdown y - convert to code h - open the help menu Right now, trying typing \"Esc + h\" to open the help/shortcut menu and peruse it. Spend a minute testing out some of the shortcuts. Note that markdown cells are quite flexible and can basically do anything wikipedia does, including adding \\LaTeX \\LaTeX -formatted equations. \\hat{H}\\psi = E \\psi \\hat{H}\\psi = E \\psi Shell commands, magic, and where to learn more \u00b6 Jupyter notebooks can also issue commands to the shell, which can be achieved using the ! symbol at the beginning of the cell: ! ls . 0 - Introduction and Jupyter Use.ipynb Exercises.ipynb 1 - Python Primer.ipynb inflammation-01.csv Exercise_Solutions.ipynb ! date Mon Jul 27 14:57:00 PDT 2020 In addition, certain things can be achieved in Jupyter notebooks using what are called \"magic\" commands, which are demarcated using the % sign. The most common of these are the magic function to enable inline plotting: % matplotlib inline and to invoke the debugger in a particular cell on an error: % pdb Automatic pdb calling has been turned ON These functions set up special functionality in the notebook. Lastly, note that Jupyter notebooks are becoming increasingly popular as tools to supplement publication. As a computational researcher, you can provide explicit documentation of your methods with embedded code that actually works for a person who wants to understand better what you're working on. In my own work, I've begun making all my plots and collecting all of my data in Jupyter notebooks to provide as supporting info for each of my recent papers. It's a bit more work, but you'll find that having this level of organization and being this transparent about your methods goes a long way. There are great resources for IPython notebooks online, and here are a few of them: Jupyter website A gallery of interesting notebooks","title":"Intro"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#introduction-to-python-and-using-jupyter-notebooks","text":"The Jupyter notebook is a platform for using and writing code in a dynamic way that allows users to combine cells of code snippets that are executed with a persistent namespace and kernel alongside markdown text for facilitating readability and visualization. In this notebook, we cover some basics of Jupyter functionality along with a discussion of some details of how you can use python in this environment and elsewhere.","title":"Introduction to Python and Using Jupyter notebooks"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#installation","text":"For this workshop, we've constructed an online environment for everyone to use in order to smooth out any platform-dependent installation issues, but you'll probably want to install the tools we use today locally on your own machine. To do this, we recommend Anaconda , which is an effective tool for python package management that can create virtual environments, comes with a pre-installed IDE, and includes all of the Jupyter functionality that you'll see here. The Anaconda installer should be detailed on the page linked above, but here's another resource for installation that might be helpful.","title":"Installation"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#code-vs-markdown","text":"Jupyter notebooks are broken down into \"cells\" which might contain either code or markdown. If you select a cell with your mouse, it should be highlighted with a green border indicating that you are in \"edit,\" mode and can edit the contents of the cell. If text reading In [ ]: is on the left hand side of the cell, it's a \"code\" cell. For example, type the following and press \"Shift + Enter\" print ( \"Hello world!\" ) Hello world! Pressing \"Shift + Enter\" executes the code in the cell, prints the output below the cell, and creates a new cell below that one. In addition to code cells, you can also write your own markdown cells by converting a cell using either the dropdown menu in the toolbar or pressing \"Esc + m\". In general, pressing escape enters \"command mode\" for which you can issue a number of commands, including f - find and replace m - convert to markdown y - convert to code h - open the help menu Right now, trying typing \"Esc + h\" to open the help/shortcut menu and peruse it. Spend a minute testing out some of the shortcuts. Note that markdown cells are quite flexible and can basically do anything wikipedia does, including adding \\LaTeX \\LaTeX -formatted equations. \\hat{H}\\psi = E \\psi \\hat{H}\\psi = E \\psi","title":"Code vs. Markdown"},{"location":"primer/01_basic_python/0%20-%20Introduction%20and%20Jupyter%20Use/#shell-commands-magic-and-where-to-learn-more","text":"Jupyter notebooks can also issue commands to the shell, which can be achieved using the ! symbol at the beginning of the cell: ! ls . 0 - Introduction and Jupyter Use.ipynb Exercises.ipynb 1 - Python Primer.ipynb inflammation-01.csv Exercise_Solutions.ipynb ! date Mon Jul 27 14:57:00 PDT 2020 In addition, certain things can be achieved in Jupyter notebooks using what are called \"magic\" commands, which are demarcated using the % sign. The most common of these are the magic function to enable inline plotting: % matplotlib inline and to invoke the debugger in a particular cell on an error: % pdb Automatic pdb calling has been turned ON These functions set up special functionality in the notebook. Lastly, note that Jupyter notebooks are becoming increasingly popular as tools to supplement publication. As a computational researcher, you can provide explicit documentation of your methods with embedded code that actually works for a person who wants to understand better what you're working on. In my own work, I've begun making all my plots and collecting all of my data in Jupyter notebooks to provide as supporting info for each of my recent papers. It's a bit more work, but you'll find that having this level of organization and being this transparent about your methods goes a long way. There are great resources for IPython notebooks online, and here are a few of them: Jupyter website A gallery of interesting notebooks","title":"Shell commands, magic, and where to learn more"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Basic Python \u00b6 Lesson 1: Expressions, variables and built-in functions \u00b6 Expressions \u00b6 An expression describes a computation. Python evaluates expressions and generates a value. We say that expressions \"evaluate to\" their result. 2019 2019 Python's arithmetic operators allows you to use a Python command line or Jupyter notebook cell as a \"calculator\" 2000 + 19 2019 2000 - 19 1981 Multiplication is done with an asterisk * 1 * 2 * ( 3 * 4 ) 24 Normal or \"true\" division is done with / . This operation will always return a float 10 / 2 5.0 Python has two other division operators. \"Floor\" division // , which returns the division rounded down to the lowest integer, and the modulo operator % , which returns the remainder of a division after substracting the next lowest integer. These are easier to understand by example: 10 // 6 1 10 % 6 4 6 // 2 3 6 % 3 0 To take an exponent, use two asterisks ** (NOT ^ ) 2 ** 3 8 Variables \u00b6 * Variables are names for values. * In Python the = symbol assigns the value on the right to the name on the left. * The variable is created when a value is assigned to it. * Every variable has a type that describes what sort of data it contains. Some of the most common types are int (integer), float (floating point number), and string (text) * Unlike many other languages, in Python you do not have to specify the type when you create a variable. Python infers the data type based on the context. This is called 'duck typing'. int variables are simply numbers. Let's assign 27 to a variable 'age'. If the variable age does not already exist, this assignment expression will create it age = 27 You can find the type of a variable using the type() function. Let's examine the type of age . type ( age ) int float variables are created by adding a decimal point to a number. Let's redefine age as 27.0 and check the type age = 27.0 type ( age ) float string variables contain text and are created using quotation marks. Both single and double quotation marks are OK. Let's try making age a string first_name = \"Ryan\" type ( first_name ) str Note that it's possible to create a string that contains only numbers age = \"27\" type ( age ) str In the Jupyter notebook, variable names are preserved between cells. In more formal language, the namespace of a notebook is preserved unless the kernel is reset, which resets all of the variable names. You can see this if you execute the following cells out of sequence. Try it out. Also try resetting the kernel and executing just the latter half. age = 42 age 42 Assigning a new value to an existing variable will replace the value of that variable age = 29 age 29 Built-in functions \u00b6 Now that we understand how Python and Jupyter handle variables, let's talk about built-in functions . These functions are available by default without issuing any special instructions. One such function is type , which we've already used. Functions are called using the function name and parentheses, which enclose the function arguments . In the example below, print is the function, and the string \"Hello world!\" is the argument. print ( \"Hello world!\" ) Hello world! print can accept multiple arguments, separate by commas, and will combine them together to generate its output, like this: print ( \"Age is\" , age , \"years\" ) Age is 29 years One of the most important things you can know when learning programming is where to access help on the things you're trying to use. There are a number of ways to access information on a function. Three of the easiest ways in Jupyter are Place your cursor inside the name of any function, and press SHIFT+TAB. This will open a small box with function information, which can be expanded by pressing tab again. Use the built-in help function, where the argument to help is the name of the function you want to know more about. Type the name of the function followed by ? , which will show the functions documentation or 'docstring' Finding help \u00b6 ## click your cursor inside 'print' and press SHIFT+TAB print ( \"this is cool\" ) this is cool help ( print ) Help on built-in function print in module builtins: print(...) print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. print ? Importing other modules and functions \u00b6 To get a function that's not built in to Python, we use the import statement. In this example, we're going to import a module called math that contains a number of functions that can be accessed by using math.FUNCTION_NAME_HERE . print ( \"I\" , \"am\" , \"a\" , \"penguin\" ) I am a penguin import math math . exp ( 2 ) 7.38905609893065 print ( \"Exponent of 2:\" , math . exp ( 2 )) print ( \"Sine of 3.1415:\" , math . sin ( 3.1415 )) Exponent of 2: 7.38905609893065 Sine of 3.1415: 9.265358966049024e-05 The Standard library includes a number of modules that come pre-installed with the python programming language itself, which is summarized in this documentation . Python's real power, however, comes in how extensible it is. Python has an ecosystem of external libraries that provide special functions for many different tasks. Three of the most common external libraries in python are: numpy - for efficient numerical array manipulation and operation scipy - for a number of tools related to scientific computing matplotlib - for plotting data and creating figures Let's use some functions from numpy and matplotlib to create a plot import numpy as np from matplotlib import pyplot inflammation = np . loadtxt ( \"inflammation-01.csv\" , delimiter = ',' ) % matplotlib inline average = np . average ( inflammation , axis = 0 ) pyplot . plot ( average ) [<matplotlib.lines.Line2D at 0x7f97f8648580>] Lesson 2: Lists and Strings \u00b6 A list stores many values in a single structure. \u00b6 A list stores many values together. Contained within square brackets [...] . Values separated by commas , . Use len to find out how many values are in a list. pressures = [ 0.273 , 0.275 , 0.277 , 0.275 , 0.276 ] print ( 'pressures:' , pressures ) pressures: [0.273, 0.275, 0.277, 0.275, 0.276] Use the built-in function len to find the length of a list \u00b6 len ( pressures ) 5 Lists may be heterogeneous \u00b6 Values can have different types goals = [ 1 , 'Create lists.' , 2 , 'Extract items from lists.' , 3 , 'Modify lists.' ] Index and slice to get information out of a string/list \u00b6 Locations are numbered from 0 rather than 1 Negative indices count backward from the end of the string Slices include the lower bound but exclude the upper bound, so (upper - lower) is the slice's length numbers = [ \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ] print ( 'first element:' , numbers [ 0 ]) print ( 'last element:' , numbers [ - 1 ]) print ( 'middle elemnets:' , numbers [ 2 : 5 ]) first element: one last element: five middle elemnets: ['three', 'four', 'five'] Indexing beyond the end of a collection is an error # NBVAL_RAISES_EXCEPTION ## This code will fail print ( '99th element of numbers is:' , numbers [ 99 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-38-89d4ca35c24b> in <module> 1 # NBVAL_RAISES_EXCEPTION 2 ## This code will fail ----> 3 print ( '99th element of numbers is:' , numbers [ 99 ] ) IndexError : list index out of range List values can be replaced by assigning to them \u00b6 Use an index expression on the left of assignment to replace a value. We say that lists are mutable because their contents can be changed after they are created pressures [ 0 ] = 0.265 print ( 'pressures is now:' , pressures ) pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276] Appending items to a list lengthens it \u00b6 use list_name.append to add items to the end of a list. primes = [ 2 , 3 , 5 ] print ( 'primes is initially:' , primes ) primes . append ( 7 ) primes . append ( 9 ) print ( 'primes has become:' , primes ) primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] * append is a method of lists * like a function, but tied to a particular object Use object_name.method_name to call methods deliberately resembles the way we refer to things in a library We will meet other methods of lists as we go along Use help(list) for a preview Extending a list adds another list to it \u00b6 extend is similar to append , but it allows you to combine two lists. teen_primes = [ 11 , 13 , 17 , 19 ] older_primes = [ 23 , 31 , 47 , 59 ] print ( 'primes is currently:' , primes ) primes . extend ( teen_primes ) print ( 'primes has now become:' , primes ) primes . append ( older_primes ) print ( 'primes has finally become:' , primes ) primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] Note that while extend maintains the \"flat\" structure of the list, appending a list to a list makes the result two-dimensional. Use del to remove items from a list entirely \u00b6 del list_name[index] removes an item from a list and shortens the list. Not a function or method, but a statement in the language. print ( 'primes before removing last item:' , primes ) del primes [ 4 ] print ( 'primes after removing last item:' , primes ) primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [23, 31, 47, 59]] The empty list contains no values \u00b6 [] is \"the zero of lists\" Helpful as a starting point for collecting values NEVER use an empty list as a default argument in a function! Strings can be sliced and indexed just like lists \u00b6 You can think of strings as lists of characters greeting = \"My name is Ryan\" print ( 'first character:' , greeting [ 0 ]) print ( 'last character:' , greeting [ - 1 ]) print ( 'middle character:' , greeting [ 2 : 5 ]) first character: M last character: n middle character: na Unlike lists, strings are immutable \u00b6 Cannot change the characters in a string after it has been created. Python considers the string to be a single value with parts, not a collection of values. # NBVAL_RAISES_EXCEPTION element = 'helium' ## This code will fail element [ 0 ] = 'C' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-44-789481aab7e2> in <module> 2 element = 'helium' 3 ## This code will fail ----> 4 element [ 0 ] = 'C' TypeError : 'str' object does not support item assignment Lesson 3: For loops \u00b6 A for loop can be used to repeat actions over a set of values. Let's print each letter in this list: name = [ 'J' , 'i' , 'm' , 'm' , 'y' ] for letter in name : print ( letter ) J i m m y For loop syntax \u00b6 For loops are constructed via the syntax for LOOP_VARIABLE in ITERABLE. The loop variable in the above example I've used is letter and the iterable I've used is the list name , which was defined as '['J', 'i', 'm', 'm', 'y']' . Other iterables include strings and dictionary keys, among others. For example, we could make name a string and iterate through it in the same way we iterated through the list: name = 'Jimmy' for letter in name : print ( letter ) J i m m y You can also use list indexing notation to limit iteration to a certain portion of an iterable. name = 'Jimmy' for letter in name [ 0 : 3 ]: print ( letter ) J i m Iterables have a length, and you can find this length using the len function. print ( \"Length of\" , name , \"is\" , len ( name )) Length of Jimmy is 5 Use enumerate() to get both an index and an item \u00b6 The enumerate function assigns an index (or counter) to each value of an iterable. It returns a tuple of (counter, value) that can be useful in for loops. For example, here we assign the index to the variable n and the value of the iterable to letter : for n , letter in enumerate ( name ): print ( \"Letter\" , n , \"-\" , letter ) Letter 0 - J Letter 1 - i Letter 2 - m Letter 3 - m Letter 4 - y Use zip() to loop over two iterables simultaneously \u00b6 The zip function can be used to loop through two iterables simultaneously (like two sides of a zipper). Here, we use zip to iterate through two strings that have the same length for letter1 , letter2 in zip ( \"Jimmy\" , \"Heath\" ): print ( letter1 , letter2 ) J H i e m a m t y h Use range() to iterate ranges of numbers \u00b6 The range function is used to construct an iterable corresponding to a set of numbers beginning at 0 and ending at a certain number: for number in range ( 6 ): print ( number ) 0 1 2 3 4 5 Logic within for loops \u00b6 range can take multiple arguments, where the first argument is interpreted as the beginning of the range. In the example below, we combine a for loop with an if statement to print only the even numbers. This makes use of the modulo % operator we covered in the Variables lesson. for number in range ( 2 , 10 ): if number % 2 == 0 : print ( number , \"is even\" ) 2 is even 4 is even 6 is even 8 is even break stops the loop \u00b6 The break statement is used to stop iterating through an iterable if some condition is met. Here, we will end our loop as soon as we encouter the number 6: for number in range ( 2 , 10 ): if number == 6 : break else : print ( number ) 2 3 4 5 A common use of for loops is to keep track of a running total of numbers. In this pattern, it's important to declare the variable that you're adding to outside the scope of the for loop. The example below makes use of the \"in place addition\" += operator, which says \"add the value on the right of the operator to the value of the variable on the left\". So x += 5 means \"add 5 to the current value of variable x . Python has similar \"in place\" operators for several other operations, including -= , *= , and /= for subtraction, multiplication, and division, respectively. my_sum = 0 for number in range ( 6 ): my_sum += number print ( \"Sum of numbers from 0 to 5 is\" , my_sum ) Sum of numbers from 0 to 5 is 15","title":"Basic Python"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#basic-python","text":"","title":"Basic Python"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-1-expressions-variables-and-built-in-functions","text":"","title":"Lesson 1: Expressions, variables and built-in functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#expressions","text":"An expression describes a computation. Python evaluates expressions and generates a value. We say that expressions \"evaluate to\" their result. 2019 2019 Python's arithmetic operators allows you to use a Python command line or Jupyter notebook cell as a \"calculator\" 2000 + 19 2019 2000 - 19 1981 Multiplication is done with an asterisk * 1 * 2 * ( 3 * 4 ) 24 Normal or \"true\" division is done with / . This operation will always return a float 10 / 2 5.0 Python has two other division operators. \"Floor\" division // , which returns the division rounded down to the lowest integer, and the modulo operator % , which returns the remainder of a division after substracting the next lowest integer. These are easier to understand by example: 10 // 6 1 10 % 6 4 6 // 2 3 6 % 3 0 To take an exponent, use two asterisks ** (NOT ^ ) 2 ** 3 8","title":"Expressions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#variables","text":"* Variables are names for values. * In Python the = symbol assigns the value on the right to the name on the left. * The variable is created when a value is assigned to it. * Every variable has a type that describes what sort of data it contains. Some of the most common types are int (integer), float (floating point number), and string (text) * Unlike many other languages, in Python you do not have to specify the type when you create a variable. Python infers the data type based on the context. This is called 'duck typing'. int variables are simply numbers. Let's assign 27 to a variable 'age'. If the variable age does not already exist, this assignment expression will create it age = 27 You can find the type of a variable using the type() function. Let's examine the type of age . type ( age ) int float variables are created by adding a decimal point to a number. Let's redefine age as 27.0 and check the type age = 27.0 type ( age ) float string variables contain text and are created using quotation marks. Both single and double quotation marks are OK. Let's try making age a string first_name = \"Ryan\" type ( first_name ) str Note that it's possible to create a string that contains only numbers age = \"27\" type ( age ) str In the Jupyter notebook, variable names are preserved between cells. In more formal language, the namespace of a notebook is preserved unless the kernel is reset, which resets all of the variable names. You can see this if you execute the following cells out of sequence. Try it out. Also try resetting the kernel and executing just the latter half. age = 42 age 42 Assigning a new value to an existing variable will replace the value of that variable age = 29 age 29","title":"Variables"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#built-in-functions","text":"Now that we understand how Python and Jupyter handle variables, let's talk about built-in functions . These functions are available by default without issuing any special instructions. One such function is type , which we've already used. Functions are called using the function name and parentheses, which enclose the function arguments . In the example below, print is the function, and the string \"Hello world!\" is the argument. print ( \"Hello world!\" ) Hello world! print can accept multiple arguments, separate by commas, and will combine them together to generate its output, like this: print ( \"Age is\" , age , \"years\" ) Age is 29 years One of the most important things you can know when learning programming is where to access help on the things you're trying to use. There are a number of ways to access information on a function. Three of the easiest ways in Jupyter are Place your cursor inside the name of any function, and press SHIFT+TAB. This will open a small box with function information, which can be expanded by pressing tab again. Use the built-in help function, where the argument to help is the name of the function you want to know more about. Type the name of the function followed by ? , which will show the functions documentation or 'docstring'","title":"Built-in functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#finding-help","text":"## click your cursor inside 'print' and press SHIFT+TAB print ( \"this is cool\" ) this is cool help ( print ) Help on built-in function print in module builtins: print(...) print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream. print ?","title":"Finding help"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#importing-other-modules-and-functions","text":"To get a function that's not built in to Python, we use the import statement. In this example, we're going to import a module called math that contains a number of functions that can be accessed by using math.FUNCTION_NAME_HERE . print ( \"I\" , \"am\" , \"a\" , \"penguin\" ) I am a penguin import math math . exp ( 2 ) 7.38905609893065 print ( \"Exponent of 2:\" , math . exp ( 2 )) print ( \"Sine of 3.1415:\" , math . sin ( 3.1415 )) Exponent of 2: 7.38905609893065 Sine of 3.1415: 9.265358966049024e-05 The Standard library includes a number of modules that come pre-installed with the python programming language itself, which is summarized in this documentation . Python's real power, however, comes in how extensible it is. Python has an ecosystem of external libraries that provide special functions for many different tasks. Three of the most common external libraries in python are: numpy - for efficient numerical array manipulation and operation scipy - for a number of tools related to scientific computing matplotlib - for plotting data and creating figures Let's use some functions from numpy and matplotlib to create a plot import numpy as np from matplotlib import pyplot inflammation = np . loadtxt ( \"inflammation-01.csv\" , delimiter = ',' ) % matplotlib inline average = np . average ( inflammation , axis = 0 ) pyplot . plot ( average ) [<matplotlib.lines.Line2D at 0x7f97f8648580>]","title":"Importing other modules and functions"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#a-list-stores-many-values-in-a-single-structure","text":"A list stores many values together. Contained within square brackets [...] . Values separated by commas , . Use len to find out how many values are in a list. pressures = [ 0.273 , 0.275 , 0.277 , 0.275 , 0.276 ] print ( 'pressures:' , pressures ) pressures: [0.273, 0.275, 0.277, 0.275, 0.276]","title":"A list stores many values in a single structure."},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-the-built-in-function-len-to-find-the-length-of-a-list","text":"len ( pressures ) 5","title":"Use the built-in function len to find the length of a list"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lists-may-be-heterogeneous","text":"Values can have different types goals = [ 1 , 'Create lists.' , 2 , 'Extract items from lists.' , 3 , 'Modify lists.' ]","title":"Lists may be heterogeneous"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#index-and-slice-to-get-information-out-of-a-stringlist","text":"Locations are numbered from 0 rather than 1 Negative indices count backward from the end of the string Slices include the lower bound but exclude the upper bound, so (upper - lower) is the slice's length numbers = [ \"one\" , \"two\" , \"three\" , \"four\" , \"five\" ] print ( 'first element:' , numbers [ 0 ]) print ( 'last element:' , numbers [ - 1 ]) print ( 'middle elemnets:' , numbers [ 2 : 5 ]) first element: one last element: five middle elemnets: ['three', 'four', 'five'] Indexing beyond the end of a collection is an error # NBVAL_RAISES_EXCEPTION ## This code will fail print ( '99th element of numbers is:' , numbers [ 99 ]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) <ipython-input-38-89d4ca35c24b> in <module> 1 # NBVAL_RAISES_EXCEPTION 2 ## This code will fail ----> 3 print ( '99th element of numbers is:' , numbers [ 99 ] ) IndexError : list index out of range","title":"Index and slice to get information out of a string/list"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#list-values-can-be-replaced-by-assigning-to-them","text":"Use an index expression on the left of assignment to replace a value. We say that lists are mutable because their contents can be changed after they are created pressures [ 0 ] = 0.265 print ( 'pressures is now:' , pressures ) pressures is now: [0.265, 0.275, 0.277, 0.275, 0.276]","title":"List values can be replaced by assigning to them"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#appending-items-to-a-list-lengthens-it","text":"use list_name.append to add items to the end of a list. primes = [ 2 , 3 , 5 ] print ( 'primes is initially:' , primes ) primes . append ( 7 ) primes . append ( 9 ) print ( 'primes has become:' , primes ) primes is initially: [2, 3, 5] primes has become: [2, 3, 5, 7, 9] * append is a method of lists * like a function, but tied to a particular object Use object_name.method_name to call methods deliberately resembles the way we refer to things in a library We will meet other methods of lists as we go along Use help(list) for a preview","title":"Appending items to a list lengthens it"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#extending-a-list-adds-another-list-to-it","text":"extend is similar to append , but it allows you to combine two lists. teen_primes = [ 11 , 13 , 17 , 19 ] older_primes = [ 23 , 31 , 47 , 59 ] print ( 'primes is currently:' , primes ) primes . extend ( teen_primes ) print ( 'primes has now become:' , primes ) primes . append ( older_primes ) print ( 'primes has finally become:' , primes ) primes is currently: [2, 3, 5, 7, 9] primes has now become: [2, 3, 5, 7, 9, 11, 13, 17, 19] primes has finally become: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] Note that while extend maintains the \"flat\" structure of the list, appending a list to a list makes the result two-dimensional.","title":"Extending a list adds another list to it"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-del-to-remove-items-from-a-list-entirely","text":"del list_name[index] removes an item from a list and shortens the list. Not a function or method, but a statement in the language. print ( 'primes before removing last item:' , primes ) del primes [ 4 ] print ( 'primes after removing last item:' , primes ) primes before removing last item: [2, 3, 5, 7, 9, 11, 13, 17, 19, [23, 31, 47, 59]] primes after removing last item: [2, 3, 5, 7, 11, 13, 17, 19, [23, 31, 47, 59]]","title":"Use del to remove items from a list entirely"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#the-empty-list-contains-no-values","text":"[] is \"the zero of lists\" Helpful as a starting point for collecting values NEVER use an empty list as a default argument in a function!","title":"The empty list contains no values"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#strings-can-be-sliced-and-indexed-just-like-lists","text":"You can think of strings as lists of characters greeting = \"My name is Ryan\" print ( 'first character:' , greeting [ 0 ]) print ( 'last character:' , greeting [ - 1 ]) print ( 'middle character:' , greeting [ 2 : 5 ]) first character: M last character: n middle character: na","title":"Strings can be sliced and indexed just like lists"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#unlike-lists-strings-are-immutable","text":"Cannot change the characters in a string after it has been created. Python considers the string to be a single value with parts, not a collection of values. # NBVAL_RAISES_EXCEPTION element = 'helium' ## This code will fail element [ 0 ] = 'C' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-44-789481aab7e2> in <module> 2 element = 'helium' 3 ## This code will fail ----> 4 element [ 0 ] = 'C' TypeError : 'str' object does not support item assignment","title":"Unlike lists, strings are immutable"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#lesson-3-for-loops","text":"A for loop can be used to repeat actions over a set of values. Let's print each letter in this list: name = [ 'J' , 'i' , 'm' , 'm' , 'y' ] for letter in name : print ( letter ) J i m m y","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#for-loop-syntax","text":"For loops are constructed via the syntax for LOOP_VARIABLE in ITERABLE. The loop variable in the above example I've used is letter and the iterable I've used is the list name , which was defined as '['J', 'i', 'm', 'm', 'y']' . Other iterables include strings and dictionary keys, among others. For example, we could make name a string and iterate through it in the same way we iterated through the list: name = 'Jimmy' for letter in name : print ( letter ) J i m m y You can also use list indexing notation to limit iteration to a certain portion of an iterable. name = 'Jimmy' for letter in name [ 0 : 3 ]: print ( letter ) J i m Iterables have a length, and you can find this length using the len function. print ( \"Length of\" , name , \"is\" , len ( name )) Length of Jimmy is 5","title":"For loop syntax"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-enumerate-to-get-both-an-index-and-an-item","text":"The enumerate function assigns an index (or counter) to each value of an iterable. It returns a tuple of (counter, value) that can be useful in for loops. For example, here we assign the index to the variable n and the value of the iterable to letter : for n , letter in enumerate ( name ): print ( \"Letter\" , n , \"-\" , letter ) Letter 0 - J Letter 1 - i Letter 2 - m Letter 3 - m Letter 4 - y","title":"Use enumerate() to get both an index and an item"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-zip-to-loop-over-two-iterables-simultaneously","text":"The zip function can be used to loop through two iterables simultaneously (like two sides of a zipper). Here, we use zip to iterate through two strings that have the same length for letter1 , letter2 in zip ( \"Jimmy\" , \"Heath\" ): print ( letter1 , letter2 ) J H i e m a m t y h","title":"Use zip() to loop over two iterables simultaneously"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#use-range-to-iterate-ranges-of-numbers","text":"The range function is used to construct an iterable corresponding to a set of numbers beginning at 0 and ending at a certain number: for number in range ( 6 ): print ( number ) 0 1 2 3 4 5","title":"Use range() to iterate ranges of numbers"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#logic-within-for-loops","text":"range can take multiple arguments, where the first argument is interpreted as the beginning of the range. In the example below, we combine a for loop with an if statement to print only the even numbers. This makes use of the modulo % operator we covered in the Variables lesson. for number in range ( 2 , 10 ): if number % 2 == 0 : print ( number , \"is even\" ) 2 is even 4 is even 6 is even 8 is even","title":"Logic within for loops"},{"location":"primer/01_basic_python/1%20-%20Python%20Primer/#break-stops-the-loop","text":"The break statement is used to stop iterating through an iterable if some condition is met. Here, we will end our loop as soon as we encouter the number 6: for number in range ( 2 , 10 ): if number == 6 : break else : print ( number ) 2 3 4 5 A common use of for loops is to keep track of a running total of numbers. In this pattern, it's important to declare the variable that you're adding to outside the scope of the for loop. The example below makes use of the \"in place addition\" += operator, which says \"add the value on the right of the operator to the value of the variable on the left\". So x += 5 means \"add 5 to the current value of variable x . Python has similar \"in place\" operators for several other operations, including -= , *= , and /= for subtraction, multiplication, and division, respectively. my_sum = 0 for number in range ( 6 ): my_sum += number print ( \"Sum of numbers from 0 to 5 is\" , my_sum ) Sum of numbers from 0 to 5 is 15","title":"break stops the loop"},{"location":"primer/01_basic_python/Exercise_Solutions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Exercises (with Solutions) \u00b6 Lesson 1 - Variables, Expressions, and Functions \u00b6 Exercise: Types \u00b6 Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? int What is the type of var2 ? float What is the type of var3 ? str What is the type of var4 ? str Exercise: Find the type \u00b6 Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } mystery = { \"a\" : 1 , \"b\" : 2 } type ( mystery ) Exercise: Converting types \u00b6 Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. var2 = 1. var4 = \"1.0\" ## float(var4) turns var4 from a str to a float float ( var4 ) ## str(var2) turns var2 from a float to a str str ( var2 ) Exercise: Imports \u00b6 Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) import os print ( \"The current directory is {} \" . format ( os . getcwd ())) import math print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) Lesson 2: Lists and Strings \u00b6 Exercise: Slicing \u00b6 What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) ## it returns a slice of element from position low to position high (starting from 0), e.g. material [ 2 : 4 ] In words, explain what does material[low:] do? (where low is an arbitrary number) ## it returns everything in element starting from position low, e.g. material [ 2 :] In words, explain what does material[:high] do? (where low is an arbitrary number) ## it returns everything in element before position high, e.g. material [: 2 ] What does material[:] do? ## it returns the entire string material [:] What about material[::2] ? material[::-1] ? ## material[::2] returns every second character of material material [:: 2 ] ## material[:-1] returns every character, in reverse order material [:: - 1 ] Exercise: Fill in the blanks \u00b6 Fill in the blanks so that the program below produces the output shown. values = ____ values . ____ ( 1 ) values . ____ ( 3 ) values . ____ ( 5 ) print ( 'first time:' , values ) values = values [ ____ ] print ( 'second time:' , values ) \u00b6 first time: [1, 3, 5] second time: [3, 5] values = [] values . append ( 1 ) values . append ( 3 ) values . append ( 5 ) print ( 'first time:' , values ) values = values [ 1 :] print ( 'second time:' , values ) Exercise: From strings to lists and back \u00b6 Given this: print ( 'string to list:' , list ( 'tin' )) print ( 'list to string:' , '-' . join ([ 'g' , 'o' , 'l' , 'd' ])) \u00b6 ['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. ## list('some string') returns a list, where each element of the list is one character of the string (including spaces), e.g. list ( 'some string' ) 2. What does ' <=> '.join(['x', 'y']) generate? ## '.'.join(list) returns the string of every element in a list, separated by the str that precedes 'join' ' <=> ' . join ([ 'x' , 'y' , 'z' ]) Exercise: Sort and Sorted \u00b6 What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() . ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) \u00b6 ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) sorted(letters) returns a new list containing the elements of letters sorted alphebetically ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) letters.sort() sorts letters alphabetically and doesn't return anyting ( result is None ) ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) Exercise: Copying (or Not) \u00b6 What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] . ## Program A old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) \u00b6 ## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Because list is a mutable type, assignment of a list to another variable creates a reference from new to old in memory. Therefore, modifying new also modifies old old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) On the other hand, a slice of a list is immutable , so assigning a slice of old to new creates a copy that can be modified independently of old old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Lesson 3: For loops \u00b6 Exercise: write a for loop that computes the sum of all of the squares from 2 to 11. \u00b6 s = 0 for i in range ( 10 ): s += pow ( i + 2 , 2 ) print ( s ) Exercise: write a for loop that prints each item in the list friends , but stops when it encounters the third value \u00b6 friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] friends = [ \"Rachel\" , \"Monica\" , \"Chandler\" , \"Ross\" , \"Joey\" ] for i , friend in enumerate ( friends ): if i == 3 : break else : print ( friend ) Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths \u00b6 zip will stop when it reaches the end of the shorter iterable s1 = 'Jim' s2 = 'Spock' for a , b in zip ( s1 , s2 ): print ( a , b ) Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop. \u00b6 * * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1) n = 5 for i in range ( n ): # rows for j in range ( i ): # columns print ( '* ' , end = \"\" ) print ( '' ) for i in range ( n , 0 , - 1 ): for j in range ( i ): print ( '* ' , end = \"\" ) print ( '' )","title":"Exercise Solutions"},{"location":"primer/01_basic_python/Exercise_Solutions/#python-primer-exercises-with-solutions","text":"","title":"Python Primer Exercises (with Solutions)"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-1-variables-expressions-and-functions","text":"","title":"Lesson 1 - Variables, Expressions, and Functions"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-types","text":"Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? int What is the type of var2 ? float What is the type of var3 ? str What is the type of var4 ? str","title":"Exercise: Types"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-find-the-type","text":"Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } mystery = { \"a\" : 1 , \"b\" : 2 } type ( mystery )","title":"Exercise: Find the type"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-converting-types","text":"Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. var2 = 1. var4 = \"1.0\" ## float(var4) turns var4 from a str to a float float ( var4 ) ## str(var2) turns var2 from a float to a str str ( var2 )","title":"Exercise: Converting types"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-imports","text":"Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) import os print ( \"The current directory is {} \" . format ( os . getcwd ())) import math print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 )))","title":"Exercise: Imports"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-slicing","text":"What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) ## it returns a slice of element from position low to position high (starting from 0), e.g. material [ 2 : 4 ] In words, explain what does material[low:] do? (where low is an arbitrary number) ## it returns everything in element starting from position low, e.g. material [ 2 :] In words, explain what does material[:high] do? (where low is an arbitrary number) ## it returns everything in element before position high, e.g. material [: 2 ] What does material[:] do? ## it returns the entire string material [:] What about material[::2] ? material[::-1] ? ## material[::2] returns every second character of material material [:: 2 ] ## material[:-1] returns every character, in reverse order material [:: - 1 ]","title":"Exercise: Slicing"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-fill-in-the-blanks","text":"Fill in the blanks so that the program below produces the output shown.","title":"Exercise: Fill in the blanks"},{"location":"primer/01_basic_python/Exercise_Solutions/#values-____-values____1-values____3-values____5-printfirst-time-values-values-values____-printsecond-time-values","text":"first time: [1, 3, 5] second time: [3, 5] values = [] values . append ( 1 ) values . append ( 3 ) values . append ( 5 ) print ( 'first time:' , values ) values = values [ 1 :] print ( 'second time:' , values )","title":"values = ____\nvalues.____(1)\nvalues.____(3)\nvalues.____(5)\nprint(&#39;first time:&#39;, values)\nvalues = values[____]\nprint(&#39;second time:&#39;, values)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-from-strings-to-lists-and-back","text":"Given this:","title":"Exercise: From strings to lists and back"},{"location":"primer/01_basic_python/Exercise_Solutions/#printstring-to-list-listtin-printlist-to-string-joing-o-l-d","text":"['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. ## list('some string') returns a list, where each element of the list is one character of the string (including spaces), e.g. list ( 'some string' ) 2. What does ' <=> '.join(['x', 'y']) generate? ## '.'.join(list) returns the string of every element in a list, separated by the str that precedes 'join' ' <=> ' . join ([ 'x' , 'y' , 'z' ])","title":"print(&#39;string to list:&#39;, list(&#39;tin&#39;))\nprint(&#39;list to string:&#39;, &#39;-&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;]))\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-sort-and-sorted","text":"What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() .","title":"Exercise: Sort and Sorted"},{"location":"primer/01_basic_python/Exercise_Solutions/#program-a-letters-listgold-result-sortedletters-printletters-is-letters-and-result-is-result","text":"## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) sorted(letters) returns a new list containing the elements of letters sorted alphebetically ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) letters.sort() sorts letters alphabetically and doesn't return anyting ( result is None ) ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result )","title":"## Program A\nletters = list(&#39;gold&#39;)\nresult = sorted(letters)\nprint(&#39;letters is&#39;, letters, &#39;and result is&#39;, result)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-copying-or-not","text":"What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] .","title":"Exercise: Copying (or Not)"},{"location":"primer/01_basic_python/Exercise_Solutions/#program-a-old-listgold-new-old-simple-assignment-new0-d-printnew-is-new-and-old-is-old","text":"## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Because list is a mutable type, assignment of a list to another variable creates a reference from new to old in memory. Therefore, modifying new also modifies old old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) On the other hand, a slice of a list is immutable , so assigning a slice of old to new creates a copy that can be modified independently of old old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old )","title":"## Program A\nold = list(&#39;gold&#39;)\nnew = old      # simple assignment\nnew[0] = &#39;D&#39;\nprint(&#39;new is&#39;, new, &#39;and old is&#39;, old)\n"},{"location":"primer/01_basic_python/Exercise_Solutions/#lesson-3-for-loops","text":"","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-write-a-for-loop-that-computes-the-sum-of-all-of-the-squares-from-2-to-11","text":"s = 0 for i in range ( 10 ): s += pow ( i + 2 , 2 ) print ( s )","title":"Exercise: write a for loop that computes the sum of all of the squares from 2 to 11."},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-write-a-for-loop-that-prints-each-item-in-the-list-friends-but-stops-when-it-encounters-the-third-value","text":"friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] friends = [ \"Rachel\" , \"Monica\" , \"Chandler\" , \"Ross\" , \"Joey\" ] for i , friend in enumerate ( friends ): if i == 3 : break else : print ( friend )","title":"Exercise: write a for loop that prints each item in the list friends, but stops when it encounters the third value"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-explain-in-a-few-words-what-happens-when-you-call-zip-on-two-iterables-that-have-different-lengths","text":"zip will stop when it reaches the end of the shorter iterable s1 = 'Jim' s2 = 'Spock' for a , b in zip ( s1 , s2 ): print ( a , b )","title":"Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths"},{"location":"primer/01_basic_python/Exercise_Solutions/#exercise-bonus-write-a-python-program-to-construct-the-following-pattern-using-a-nested-for-loop","text":"* * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1) n = 5 for i in range ( n ): # rows for j in range ( i ): # columns print ( '* ' , end = \"\" ) print ( '' ) for i in range ( n , 0 , - 1 ): for j in range ( i ): print ( '* ' , end = \"\" ) print ( '' )","title":"Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop."},{"location":"primer/01_basic_python/Exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Python Primer Exercises (with Solutions) \u00b6 Lesson 1 - Variables, Expressions, and Functions \u00b6 Exercise: Types \u00b6 Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? What is the type of var2 ? What is the type of var3 ? What is the type of var4 ? Exercise: Find the type \u00b6 Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 } Exercise: Converting types \u00b6 Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does. Exercise: Imports \u00b6 Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 ))) Lesson 2: Lists and Strings \u00b6 Exercise: Slicing \u00b6 What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) In words, explain what does material[low:] do? (where low is an arbitrary number) In words, explain what does material[:high] do? (where low is an arbitrary number) What does material[:] do? What about material[::2] ? material[::-1] ? Exercise: Fill in the blanks \u00b6 Fill in the blanks so that the program below produces the output shown. values = ____ values . ____ ( 1 ) values . ____ ( 3 ) values . ____ ( 5 ) print ( 'first time:' , values ) values = values [ ____ ] print ( 'second time:' , values ) \u00b6 first time: [1, 3, 5] second time: [3, 5] Exercise: From strings to lists and back \u00b6 Given this: print ( 'string to list:' , list ( 'tin' )) print ( 'list to string:' , '-' . join ([ 'g' , 'o' , 'l' , 'd' ])) \u00b6 ['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. 2. What does ' <=> '.join(['x', 'y']) generate? Exercise: Sort and Sorted \u00b6 What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() . ## Program A letters = list ( 'gold' ) result = sorted ( letters ) print ( 'letters is' , letters , 'and result is' , result ) \u00b6 ## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result ) Exercise: Copying (or Not) \u00b6 What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] . ## Program A old = list ( 'gold' ) new = old # simple assignment new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) \u00b6 ## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old ) Lesson 3: For loops \u00b6 Exercise: write a for loop that computes the sum of all of the squares from 2 to 11. \u00b6 Exercise: write a for loop that prints each item in the list friends , but stops when it encounters the third value \u00b6 friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"] Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths \u00b6 zip will stop when it reaches the end of the shorter iterable Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop. \u00b6 * * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1)","title":"Exercises"},{"location":"primer/01_basic_python/Exercises/#python-primer-exercises-with-solutions","text":"","title":"Python Primer Exercises (with Solutions)"},{"location":"primer/01_basic_python/Exercises/#lesson-1-variables-expressions-and-functions","text":"","title":"Lesson 1 - Variables, Expressions, and Functions"},{"location":"primer/01_basic_python/Exercises/#exercise-types","text":"Consider the following code: var1 = 1 var2 = 1. var3 = \"one\" var4 = \"3.14159\" What is the type of var1 ? What is the type of var2 ? What is the type of var3 ? What is the type of var4 ?","title":"Exercise: Types"},{"location":"primer/01_basic_python/Exercises/#exercise-find-the-type","text":"Determine the type of the variable mystery using a built-in function mystery = { \"a\" : 1 , \"b\" : 2 }","title":"Exercise: Find the type"},{"location":"primer/01_basic_python/Exercises/#exercise-converting-types","text":"Given this: var2 = 1. var4 = \"1.0\" Explain in simple terms what float(var4) does. Explain in simple terms what str(var2) does.","title":"Exercise: Converting types"},{"location":"primer/01_basic_python/Exercises/#exercise-imports","text":"Fill in the blanks so that the two programs below run without errors. import __ print ( \"The current directory is {} \" . format ( os . getcwd ())) import ____ print ( \"The square root of 2 is {} \" . format ( math . sqrt ( 2 )))","title":"Exercise: Imports"},{"location":"primer/01_basic_python/Exercises/#lesson-2-lists-and-strings","text":"","title":"Lesson 2: Lists and Strings"},{"location":"primer/01_basic_python/Exercises/#exercise-slicing","text":"What does the following print: material = 'carbon' print ( 'material[1:3] is:' , material [ 1 : 3 ]) In words, explain what does material[low:high] do? (where low and high are arbitrary numbers) In words, explain what does material[low:] do? (where low is an arbitrary number) In words, explain what does material[:high] do? (where low is an arbitrary number) What does material[:] do? What about material[::2] ? material[::-1] ?","title":"Exercise: Slicing"},{"location":"primer/01_basic_python/Exercises/#exercise-fill-in-the-blanks","text":"Fill in the blanks so that the program below produces the output shown.","title":"Exercise: Fill in the blanks"},{"location":"primer/01_basic_python/Exercises/#values-____-values____1-values____3-values____5-printfirst-time-values-values-values____-printsecond-time-values","text":"first time: [1, 3, 5] second time: [3, 5]","title":"values = ____\nvalues.____(1)\nvalues.____(3)\nvalues.____(5)\nprint(&#39;first time:&#39;, values)\nvalues = values[____]\nprint(&#39;second time:&#39;, values)\n"},{"location":"primer/01_basic_python/Exercises/#exercise-from-strings-to-lists-and-back","text":"Given this:","title":"Exercise: From strings to lists and back"},{"location":"primer/01_basic_python/Exercises/#printstring-to-list-listtin-printlist-to-string-joing-o-l-d","text":"['t', 'i', 'n'] 'g-o-l-d' Explain in simple terms what list('some string') does. 2. What does ' <=> '.join(['x', 'y']) generate?","title":"print(&#39;string to list:&#39;, list(&#39;tin&#39;))\nprint(&#39;list to string:&#39;, &#39;-&#39;.join([&#39;g&#39;, &#39;o&#39;, &#39;l&#39;, &#39;d&#39;]))\n"},{"location":"primer/01_basic_python/Exercises/#exercise-sort-and-sorted","text":"What do these two programs print? In simple terms, explain the difference between sorted(letters) and letters.sort() .","title":"Exercise: Sort and Sorted"},{"location":"primer/01_basic_python/Exercises/#program-a-letters-listgold-result-sortedletters-printletters-is-letters-and-result-is-result","text":"## Program B letters = list ( 'gold' ) result = letters . sort () print ( 'letters is' , letters , 'and result is' , result )","title":"## Program A\nletters = list(&#39;gold&#39;)\nresult = sorted(letters)\nprint(&#39;letters is&#39;, letters, &#39;and result is&#39;, result)\n"},{"location":"primer/01_basic_python/Exercises/#exercise-copying-or-not","text":"What do these two programs print? In simple terms, explain the difference between new = old and new = old[:] .","title":"Exercise: Copying (or Not)"},{"location":"primer/01_basic_python/Exercises/#program-a-old-listgold-new-old-simple-assignment-new0-d-printnew-is-new-and-old-is-old","text":"## Program B old = list ( 'gold' ) new = old [:] # assigning a slice new [ 0 ] = 'D' print ( 'new is' , new , 'and old is' , old )","title":"## Program A\nold = list(&#39;gold&#39;)\nnew = old      # simple assignment\nnew[0] = &#39;D&#39;\nprint(&#39;new is&#39;, new, &#39;and old is&#39;, old)\n"},{"location":"primer/01_basic_python/Exercises/#lesson-3-for-loops","text":"","title":"Lesson 3: For loops"},{"location":"primer/01_basic_python/Exercises/#exercise-write-a-for-loop-that-computes-the-sum-of-all-of-the-squares-from-2-to-11","text":"","title":"Exercise: write a for loop that computes the sum of all of the squares from 2 to 11."},{"location":"primer/01_basic_python/Exercises/#exercise-write-a-for-loop-that-prints-each-item-in-the-list-friends-but-stops-when-it-encounters-the-third-value","text":"friends = [\"Rachel\", \"Monica\", \"Chandler\", \"Ross\", \"Joey\"]","title":"Exercise: write a for loop that prints each item in the list friends, but stops when it encounters the third value"},{"location":"primer/01_basic_python/Exercises/#exercise-explain-in-a-few-words-what-happens-when-you-call-zip-on-two-iterables-that-have-different-lengths","text":"zip will stop when it reaches the end of the shorter iterable","title":"Exercise: Explain in a few words what happens when you call zip on two iterables that have different lengths"},{"location":"primer/01_basic_python/Exercises/#exercise-bonus-write-a-python-program-to-construct-the-following-pattern-using-a-nested-for-loop","text":"* * * * * * * * * * * * * * * * * * * * * * * * * Hint: by default the print function inserts a newline character at the end of every line it prints. To suppress this, set the end argument to \"\", like print(\"something\", end=\"\") Hint: you can iterate through a range of numbers in reverse order by passing a negative number as a third argument to range , e.g. range(0,10,-1)","title":"Exercise (bonus): Write a Python program to construct the following pattern, using a nested for loop."},{"location":"primer/02_building_logic/Exercises05-Conditionals/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercises 5: Conditionals \u00b6 Exercise: \u00b6 Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == __ : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == __ : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Exercise: \u00b6 Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer \"A,\" discoverer \"B,\" and both. import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = __ , __ for name in names : if discover0 in name : A = __ if discover1 in name : B = __ if __ and __ : print ( \"For \" , element_name , \", A and B is true!\" ) elif __ : print ( \"For \" , element_name , \", A is true!\" ) elif __ : print ( \"For \" , element_name , \", B is true!\" )","title":"Exercises05 Conditionals"},{"location":"primer/02_building_logic/Exercises05-Conditionals/#exercises-5-conditionals","text":"","title":"Exercises 5: Conditionals"},{"location":"primer/02_building_logic/Exercises05-Conditionals/#exercise","text":"Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == __ : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == __ : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" )","title":"Exercise:"},{"location":"primer/02_building_logic/Exercises05-Conditionals/#exercise_1","text":"Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer \"A,\" discoverer \"B,\" and both. import os from monty.serialization import loadfn data_dir = \"./data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = __ , __ for name in names : if discover0 in name : A = __ if discover1 in name : B = __ if __ and __ : print ( \"For \" , element_name , \", A and B is true!\" ) elif __ : print ( \"For \" , element_name , \", A is true!\" ) elif __ : print ( \"For \" , element_name , \", B is true!\" )","title":"Exercise:"},{"location":"primer/02_building_logic/Exercises06-SetsAndDictionaries/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercises 6: Sets and Dictionaries \u00b6 Exercise: create a histogram \u00b6 numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if __ not in __ : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Exercise: How heavy is this molecule? \u00b6 You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` # ... #print(mol_weight)","title":"Exercises06 SetsAndDictionaries"},{"location":"primer/02_building_logic/Exercises06-SetsAndDictionaries/#exercises-6-sets-and-dictionaries","text":"","title":"Exercises 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/Exercises06-SetsAndDictionaries/#exercise-create-a-histogram","text":"numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if __ not in __ : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers )))","title":"Exercise: create a histogram"},{"location":"primer/02_building_logic/Exercises06-SetsAndDictionaries/#exercise-how-heavy-is-this-molecule","text":"You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"./data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` # ... #print(mol_weight)","title":"Exercise: How heavy is this molecule?"},{"location":"primer/02_building_logic/Exercises07-WritingFunctions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercises 7: Writing Functions \u00b6 Exercise: Find the first \u00b6 Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in ____ : if ____ : return ____ Exercise : Running sum \u00b6 Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why? Exercise: How's your phase-change memory? \u00b6 A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): # Fill this in. pass my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal ))","title":"Exercises07 WritingFunctions"},{"location":"primer/02_building_logic/Exercises07-WritingFunctions/#exercises-7-writing-functions","text":"","title":"Exercises 7: Writing Functions"},{"location":"primer/02_building_logic/Exercises07-WritingFunctions/#exercise-find-the-first","text":"Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in ____ : if ____ : return ____","title":"Exercise: Find the first"},{"location":"primer/02_building_logic/Exercises07-WritingFunctions/#exercise-running-sum","text":"Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why?","title":"Exercise : Running sum"},{"location":"primer/02_building_logic/Exercises07-WritingFunctions/#exercise-hows-your-phase-change-memory","text":"A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"./data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): # Fill this in. pass my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal ))","title":"Exercise: How's your phase-change memory?"},{"location":"primer/02_building_logic/Exercises08-TestYourSkills/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercises 8: Test your Skills \u00b6 Now it's time to put your Python skills to the test! \u00b6 Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { __ : __ for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ __ ][ 'discovered_by' ]: if discoverer in __ : elem = Element ( element_symbols [ element_name ]) all_elements . append ( __ ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ __ ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 # If statement if \"year_discovered\" is less than \"prior_to\" if __ : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ __ ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ __ ], atomic_fractions , __ ): molar_weight += __ * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for __ in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], __ , abundances ): abundance_metric *= ( abundance ) ** frac abundance_metric *= 100 return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) # Hint: \"&\" operator is used for intersection of two sets, #. and \"|\" for union intersection = set ( elements ) __ set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( __ ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( __ ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : __ , \"crystal\" : __ } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ __ ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ __ ] for x in value_map ] crystals_matched = [ x [ __ ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ __ ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , __ ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Exercises08 TestYourSkills"},{"location":"primer/02_building_logic/Exercises08-TestYourSkills/#exercises-8-test-your-skills","text":"","title":"Exercises 8: Test your Skills"},{"location":"primer/02_building_logic/Exercises08-TestYourSkills/#now-its-time-to-put-your-python-skills-to-the-test","text":"Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"./data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { __ : __ for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ __ ][ 'discovered_by' ]: if discoverer in __ : elem = Element ( element_symbols [ element_name ]) all_elements . append ( __ ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ __ ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 # If statement if \"year_discovered\" is less than \"prior_to\" if __ : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ __ ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ __ ], atomic_fractions , __ ): molar_weight += __ * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for __ in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], __ , abundances ): abundance_metric *= ( abundance ) ** frac abundance_metric *= 100 return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) # Hint: \"&\" operator is used for intersection of two sets, #. and \"|\" for union intersection = set ( elements ) __ set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( __ ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( __ ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : __ , \"crystal\" : __ } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ __ ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ __ ] for x in value_map ] crystals_matched = [ x [ __ ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ __ ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , __ ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Now it's time to put your Python skills to the test!"},{"location":"primer/02_building_logic/Lesson05-Conditionals/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Lesson 5: Conditionals \u00b6 In our work, we often want to our programs to be make decisions based on what's going on at the time. Like most other programming languages, python supports conditional statements . The way in which we make decisions in our code based on conditions is through the if statement. Booleans \u00b6 The boolean, or bool , datatype in Python is useful for logic expressions, and can either be True or False . print ( 3 == 2 ) mybool = 3 > 2 print ( \"My boolean type = \" , type ( mybool )) print ( \"My boolean value = \" , mybool ) The if Statement \u00b6 Let's start with an illustrative example of the state of matter of water (H 2 O) based on the temperature: water_temperature = - 1 # degrees celsius Below is the simple if statement: \"if the temperature of the water is greater than 100 \u00b0C, it must be boiling\" if water_temperature > 100 : print ( 'Boiling!' ) Now, let's add an else catch to our if statement: \"if ... greater than ..., __otherwise__, the water is not boiling\" if water_temperature > 100 : print ( 'Boiling!' ) else : print ( 'Not boiling!' ) We can increase the number of levels of if statement in the following manner: if (condition #1): execute code for case #1 ... . . . elif (condition #k): execute code for case #k ... . . . elif (condition #n): execute code for case #n ... else: execute \"catch all\" case ... In principle, there is no limit to the number of intermediate elif or \"else, if\" checks. water_temperature = - 5 if water_temperature > 100 : print ( 'Boiling!' ) elif water_temperature > 0 : print ( 'Liquid!' ) else : print ( 'Solid!' ) Note that conditions are demarcated using indentation . This is a contentious property of Python, but is implemented primarily because it makes code much easier to read. Note also that the indentation level can be almost any combination of whitespace characters (tabs and spaces), but elements of the same indentation block must use the same type of indentation. Because it gets confusing to use multiple types, the python style guide strongly recommends using 4 spaces to indent, which is the default in the jupyter notebook for example. This is sometimes more difficult to toggle in text editors, but most of them have online resources for setting up your text editor to use tabs and indentation in a way that conforms to python's style. What is truth? \u00b6 We can typecast another datatype as bool using bool() (we can do this for other fundamental datatypes such as int and float ). The results of some of these casting examples are quite interesting! bool ( 5 ) bool ( \"beauty\" ) bool ( \"\" ) bool ([]) bool ({}) bool ( 0 ) bool ( None ) Be very careful with this! Python's \"falsy\" functionality makes code fun to write and easier to read, but can cause problems. For example, many people will put a simple if statement as a conditional on whether the variable is stored as a falsy value (e. g. None). Part of the reason we're mentioning this today is that this is often the case in codes that use a lot of serialization like pymatgen. temperature = 0 # store the temperature as a number if you want it to do something if temperature : print ( \"Temperature is\" , temperature )","title":"Lesson05 Conditionals"},{"location":"primer/02_building_logic/Lesson05-Conditionals/#lesson-5-conditionals","text":"In our work, we often want to our programs to be make decisions based on what's going on at the time. Like most other programming languages, python supports conditional statements . The way in which we make decisions in our code based on conditions is through the if statement.","title":"Lesson 5: Conditionals"},{"location":"primer/02_building_logic/Lesson05-Conditionals/#booleans","text":"The boolean, or bool , datatype in Python is useful for logic expressions, and can either be True or False . print ( 3 == 2 ) mybool = 3 > 2 print ( \"My boolean type = \" , type ( mybool )) print ( \"My boolean value = \" , mybool )","title":"Booleans"},{"location":"primer/02_building_logic/Lesson05-Conditionals/#the-if-statement","text":"Let's start with an illustrative example of the state of matter of water (H 2 O) based on the temperature: water_temperature = - 1 # degrees celsius Below is the simple if statement: \"if the temperature of the water is greater than 100 \u00b0C, it must be boiling\" if water_temperature > 100 : print ( 'Boiling!' ) Now, let's add an else catch to our if statement: \"if ... greater than ..., __otherwise__, the water is not boiling\" if water_temperature > 100 : print ( 'Boiling!' ) else : print ( 'Not boiling!' ) We can increase the number of levels of if statement in the following manner: if (condition #1): execute code for case #1 ... . . . elif (condition #k): execute code for case #k ... . . . elif (condition #n): execute code for case #n ... else: execute \"catch all\" case ... In principle, there is no limit to the number of intermediate elif or \"else, if\" checks. water_temperature = - 5 if water_temperature > 100 : print ( 'Boiling!' ) elif water_temperature > 0 : print ( 'Liquid!' ) else : print ( 'Solid!' ) Note that conditions are demarcated using indentation . This is a contentious property of Python, but is implemented primarily because it makes code much easier to read. Note also that the indentation level can be almost any combination of whitespace characters (tabs and spaces), but elements of the same indentation block must use the same type of indentation. Because it gets confusing to use multiple types, the python style guide strongly recommends using 4 spaces to indent, which is the default in the jupyter notebook for example. This is sometimes more difficult to toggle in text editors, but most of them have online resources for setting up your text editor to use tabs and indentation in a way that conforms to python's style.","title":"The if Statement"},{"location":"primer/02_building_logic/Lesson05-Conditionals/#what-is-truth","text":"We can typecast another datatype as bool using bool() (we can do this for other fundamental datatypes such as int and float ). The results of some of these casting examples are quite interesting! bool ( 5 ) bool ( \"beauty\" ) bool ( \"\" ) bool ([]) bool ({}) bool ( 0 ) bool ( None ) Be very careful with this! Python's \"falsy\" functionality makes code fun to write and easier to read, but can cause problems. For example, many people will put a simple if statement as a conditional on whether the variable is stored as a falsy value (e. g. None). Part of the reason we're mentioning this today is that this is often the case in codes that use a lot of serialization like pymatgen. temperature = 0 # store the temperature as a number if you want it to do something if temperature : print ( \"Temperature is\" , temperature )","title":"What is truth?"},{"location":"primer/02_building_logic/Lesson06-SetsAndDictionaries/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Lesson 6: Sets and Dictionaries \u00b6 Use a set to store unique values \u00b6 Possible to initialize a set with {...} But must use set() to create an empty set primes = { 2 , 3 , 5 , 7 } print ( 'is 3 prime?' , 3 in primes ) print ( 'is 9 prime?' , 9 in primes ) * Intersection, union, etc. odds = { 3 , 5 , 7 , 9 } print ( 'intersection' , odds & primes ) print ( 'union' , odds | primes ) Sets are mutable \u00b6 But only store unique values primes . add ( 11 ) print ( 'primes becomes' , primes ) primes . discard ( 7 ) print ( 'after removal' , primes ) primes . add ( 11 ) print ( 'after adding 11 again' , primes ) Sets are unordered \u00b6 Values are stored by hashing , which is intentionally as random as possible names = { 'Hopper' , 'Cori' , 'Kohn' } for n in names : print ( n ) Use a dictionary to store key/value pairs \u00b6 Equivalently, store extra information with elements of a set. birthdays = { 'Hopper' : 1906 , 'Cori' : 1896 } print ( birthdays [ 'Hopper' ]) birthdays [ 'Kohn' ] = 1823 # oops birthdays [ 'Kohn' ] = 1923 # that's better print ( birthdays ) * Just an accident that keys are in order of when entered. * Like sets, dictionaries store keys by hashing, which is as random as possible Set values and dictionary keys must be immutable \u00b6 Changing them after insertion would leave data in the wrong place Use a tuple for multi-valued keys people = {( 'Grace' , 'Hopper' ): 1906 , ( 'Gerty' , 'Cory' ): 1896 , ( 'Walter' , 'Kohn' ): 1923 } You can destructure a tuple in the heading of a for loop: for ( first , last ) in people : print ( first , 'was born in' , people [( first , last )])","title":"Lesson06 SetsAndDictionaries"},{"location":"primer/02_building_logic/Lesson06-SetsAndDictionaries/#lesson-6-sets-and-dictionaries","text":"","title":"Lesson 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/Lesson06-SetsAndDictionaries/#use-a-set-to-store-unique-values","text":"Possible to initialize a set with {...} But must use set() to create an empty set primes = { 2 , 3 , 5 , 7 } print ( 'is 3 prime?' , 3 in primes ) print ( 'is 9 prime?' , 9 in primes ) * Intersection, union, etc. odds = { 3 , 5 , 7 , 9 } print ( 'intersection' , odds & primes ) print ( 'union' , odds | primes )","title":"Use a set to store unique values"},{"location":"primer/02_building_logic/Lesson06-SetsAndDictionaries/#sets-are-mutable","text":"But only store unique values primes . add ( 11 ) print ( 'primes becomes' , primes ) primes . discard ( 7 ) print ( 'after removal' , primes ) primes . add ( 11 ) print ( 'after adding 11 again' , primes )","title":"Sets are mutable"},{"location":"primer/02_building_logic/Lesson06-SetsAndDictionaries/#sets-are-unordered","text":"Values are stored by hashing , which is intentionally as random as possible names = { 'Hopper' , 'Cori' , 'Kohn' } for n in names : print ( n )","title":"Sets are unordered"},{"location":"primer/02_building_logic/Lesson06-SetsAndDictionaries/#use-a-dictionary-to-store-keyvalue-pairs","text":"Equivalently, store extra information with elements of a set. birthdays = { 'Hopper' : 1906 , 'Cori' : 1896 } print ( birthdays [ 'Hopper' ]) birthdays [ 'Kohn' ] = 1823 # oops birthdays [ 'Kohn' ] = 1923 # that's better print ( birthdays ) * Just an accident that keys are in order of when entered. * Like sets, dictionaries store keys by hashing, which is as random as possible","title":"Use a dictionary to store key/value pairs"},{"location":"primer/02_building_logic/Lesson06-SetsAndDictionaries/#set-values-and-dictionary-keys-must-be-immutable","text":"Changing them after insertion would leave data in the wrong place Use a tuple for multi-valued keys people = {( 'Grace' , 'Hopper' ): 1906 , ( 'Gerty' , 'Cory' ): 1896 , ( 'Walter' , 'Kohn' ): 1923 } You can destructure a tuple in the heading of a for loop: for ( first , last ) in people : print ( first , 'was born in' , people [( first , last )])","title":"Set values and dictionary keys must be immutable"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Lesson 7: Writing Functions \u00b6 Break down programs into functions \u00b6 Readability: human beings can only keep a few items in working memory at a time. Encapsulate complexity so that we can treat it as a single \u201cthing\u201d. Reuse: write one time, use many times. Testing: components with well-defined boundaries are easier to test. Define a function using def with a name, parameters, and a block of code \u00b6 Function name must obey the same rules as variable names Put parameters in parentheses Then a colon, then an indented code block # Empty parentheses if the function doesn't take any inputs: def print_greeting (): print ( 'Hello!' ) Arguments in call are matched to parameters in definition \u00b6 def print_date ( year , month , day ): joined = str ( year ) + '/' + str ( month ) + '/' + str ( day ) print ( joined ) print_date ( 1871 , 3 , 19 ) Functions may return a result to their caller using return \u00b6 May occur anywhere in the function But functions are easier to understand if return occurs At the start, to handle special cases At the very end, with a final result Functions without explicit return produce None def average ( values ): if len ( values ) == 0 : return None return sum ( values ) / len ( values ) a = average ([ 1 , 3 , 4 ]) print ( 'average of actual values:' , a ) print ( 'average of empty list:' , average ([])) result = print_date ( 1871 , 3 , 19 ) print ( 'result of call is:' , result ) Can specify default values for parameters \u00b6 All paramters with defaults must come after all parameters without. Otherwise, argument-to-parameter matching would be ambigious. Makes common cases simpler, and signals intent def my_sum ( values , scale = 1.0 ): result = 0.0 for v in values : result += v * scale return result print ( 'my_sum with default:' , my_sum ([ 1 , 2 , 3 ])) print ( 'sum with factor:' , my_sum ([ 1 , 2 , 3 ], 0.5 )) # Succinctly... def my_sum ( values , scale = 1.0 ): return sum ( v * scale for v in values ) Can pass parameters by name \u00b6 Helpful when functions have lots of options If you have a procedure with ten parameters, you probably missed some. -- from \"Epigrams in Programming\", by Alan J. Perlis print ( 'out of order:' , my_sum ( scale = 0.25 , values = [ 1 , 2 , 3 ])) Functions can take a variable number of arguments \u00b6 Prefix at most one parameter's name with * . By convention, everyone calls the parameters *args . All \"extra\" paramters are put in a list-like structure assigned to that parameter def total ( scale , * args ): return sum ( a * scale for a in args ) print ( 'with one value:' , total ( 0.5 , 1 )) print ( 'with two values:' , total ( 0.5 , 1 , 3 )) Functions can return multiple values \u00b6 This is just a special case of many-to-many assignment red , green , blue = 10 , 50 , 180 def order ( a , b ): if a < b : return a , b else : return b , a low , high = order ( 10 , 5 ) print ( 'order(10, 5):' , low , high )","title":"Lesson07 WritingFunctions"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#lesson-7-writing-functions","text":"","title":"Lesson 7: Writing Functions"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#break-down-programs-into-functions","text":"Readability: human beings can only keep a few items in working memory at a time. Encapsulate complexity so that we can treat it as a single \u201cthing\u201d. Reuse: write one time, use many times. Testing: components with well-defined boundaries are easier to test.","title":"Break down programs into functions"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#define-a-function-using-def-with-a-name-parameters-and-a-block-of-code","text":"Function name must obey the same rules as variable names Put parameters in parentheses Then a colon, then an indented code block # Empty parentheses if the function doesn't take any inputs: def print_greeting (): print ( 'Hello!' )","title":"Define a function using def with a name, parameters, and a block of code"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#arguments-in-call-are-matched-to-parameters-in-definition","text":"def print_date ( year , month , day ): joined = str ( year ) + '/' + str ( month ) + '/' + str ( day ) print ( joined ) print_date ( 1871 , 3 , 19 )","title":"Arguments in call are matched to parameters in definition"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#functions-may-return-a-result-to-their-caller-using-return","text":"May occur anywhere in the function But functions are easier to understand if return occurs At the start, to handle special cases At the very end, with a final result Functions without explicit return produce None def average ( values ): if len ( values ) == 0 : return None return sum ( values ) / len ( values ) a = average ([ 1 , 3 , 4 ]) print ( 'average of actual values:' , a ) print ( 'average of empty list:' , average ([])) result = print_date ( 1871 , 3 , 19 ) print ( 'result of call is:' , result )","title":"Functions may return a result to their caller using return"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#can-specify-default-values-for-parameters","text":"All paramters with defaults must come after all parameters without. Otherwise, argument-to-parameter matching would be ambigious. Makes common cases simpler, and signals intent def my_sum ( values , scale = 1.0 ): result = 0.0 for v in values : result += v * scale return result print ( 'my_sum with default:' , my_sum ([ 1 , 2 , 3 ])) print ( 'sum with factor:' , my_sum ([ 1 , 2 , 3 ], 0.5 )) # Succinctly... def my_sum ( values , scale = 1.0 ): return sum ( v * scale for v in values )","title":"Can specify default values for parameters"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#can-pass-parameters-by-name","text":"Helpful when functions have lots of options If you have a procedure with ten parameters, you probably missed some. -- from \"Epigrams in Programming\", by Alan J. Perlis print ( 'out of order:' , my_sum ( scale = 0.25 , values = [ 1 , 2 , 3 ]))","title":"Can pass parameters by name"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#functions-can-take-a-variable-number-of-arguments","text":"Prefix at most one parameter's name with * . By convention, everyone calls the parameters *args . All \"extra\" paramters are put in a list-like structure assigned to that parameter def total ( scale , * args ): return sum ( a * scale for a in args ) print ( 'with one value:' , total ( 0.5 , 1 )) print ( 'with two values:' , total ( 0.5 , 1 , 3 ))","title":"Functions can take a variable number of arguments"},{"location":"primer/02_building_logic/Lesson07-WritingFunctions/#functions-can-return-multiple-values","text":"This is just a special case of many-to-many assignment red , green , blue = 10 , 50 , 180 def order ( a , b ): if a < b : return a , b else : return b , a low , high = order ( 10 , 5 ) print ( 'order(10, 5):' , low , high )","title":"Functions can return multiple values"},{"location":"primer/02_building_logic/solved/Exercises05-Conditionals/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercises 5: Conditionals \u00b6 Exercise: \u00b6 Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == 'F' : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == 'C' : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" ) Exercise: \u00b6 Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer A, discoverer B, and both! import os from monty.serialization import loadfn data_dir = \"../data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = False , False for name in names : if discover0 in name : A = True if discover1 in name : B = True if A and B : print ( \"For \" , element_name , \", A and B is true!\" ) elif A : print ( \"For \" , element_name , \", A is true!\" ) elif B : print ( \"For \" , element_name , \", B is true!\" )","title":"Exercises05 Conditionals"},{"location":"primer/02_building_logic/solved/Exercises05-Conditionals/#exercises-5-conditionals","text":"","title":"Exercises 5: Conditionals"},{"location":"primer/02_building_logic/solved/Exercises05-Conditionals/#exercise","text":"Write a Python program to convert temperatures to and from celsius, fahrenheit. Formula : c/5 = f-32/9 (where c = temperature in celsius and f = temperature in fahrenheit ) Expected Output : 60\u00b0C is 140 in Fahrenheit 45\u00b0F is 7 in Celsius # gather input from the user temp = input ( \"Input the temperature you like to convert? (e.g., 45F, 102C etc.) : \" ) # parse the string of input from the user degree = int ( temp [: - 1 ]) i_convention = temp [ - 1 ] if i_convention . upper () == 'F' : result = int ( round (( 9 * degree ) / 5 + 32 )) o_convention = \"Fahrenheit\" elif i_convention . upper () == 'C' : result = int ( round (( degree - 32 ) * 5 / 9 )) o_convention = \"Celsius\" else : print ( \"Input proper convention.\" ) quit () print ( \"The temperature in\" , o_convention , \"is\" , result , \"degrees.\" )","title":"Exercise:"},{"location":"primer/02_building_logic/solved/Exercises05-Conditionals/#exercise_1","text":"Who discovered your favorite elements? Let's write a simple test to see which elements were discovered by discoverer A, discoverer B, and both! import os from monty.serialization import loadfn data_dir = \"../data/\" # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) from pymatgen.core import Element # The discoverers we want to explore... discover0 = \"Berkeley\" #discover0 = \"Ghiorso\" discover1 = \"Russia\" # Loop through discoverers to find which elements they discovered for element_name in discovery_dict : names = discovery_dict [ element_name ][ 'discovered_by' ] A , B = False , False for name in names : if discover0 in name : A = True if discover1 in name : B = True if A and B : print ( \"For \" , element_name , \", A and B is true!\" ) elif A : print ( \"For \" , element_name , \", A is true!\" ) elif B : print ( \"For \" , element_name , \", B is true!\" )","title":"Exercise:"},{"location":"primer/02_building_logic/solved/Exercises06-SetsAndDictionaries/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercises 6: Sets and Dictionaries \u00b6 Exercise: create a histogram \u00b6 numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if n not in count : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers ))) Exercise: How heavy is this molecule? \u00b6 You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"../data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` mol_weight = 0.0 for specie , number in methane : mol_weight += number * atomic_weights [ specie ] print ( mol_weight )","title":"Exercises06 SetsAndDictionaries"},{"location":"primer/02_building_logic/solved/Exercises06-SetsAndDictionaries/#exercises-6-sets-and-dictionaries","text":"","title":"Exercises 6: Sets and Dictionaries"},{"location":"primer/02_building_logic/solved/Exercises06-SetsAndDictionaries/#exercise-create-a-histogram","text":"numbers = [ 1 , 0 , 1 , 2 , 0 , 0 , 1 , 2 , 1 , 3 , 1 , 0 , 2 ] count = {} for n in numbers : if n not in count : count [ n ] = 1 else : count [ n ] = count [ n ] + 1 print ( count ) Reminder: there are lots of useful Python libraries, especially the \"standard library\" that comes with Python: from collections import Counter print ( Counter ( numbers )) print ( dict ( Counter ( numbers )))","title":"Exercise: create a histogram"},{"location":"primer/02_building_logic/solved/Exercises06-SetsAndDictionaries/#exercise-how-heavy-is-this-molecule","text":"You are given two things: a dictionary mapping atomic symbols to atomic weights ( mp_workshop.data.atomic_weights ), and a list of (atomic_symbol, count) pairs for a molecule. # Example molecules: methane = [( 'C' , 1 ), ( 'H' , 4 )] aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] Print that molecule's molecular weight. import os from monty.serialization import loadfn data_dir = \"../data/\" atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # atomic weight is 16.0423 methane = [( 'C' , 1 ), ( 'H' , 4 )] # atomic weight is 100.1421 aminothiazole = [( 'C' , 3 ), ( 'H' , 4 ), ( 'N' , 2 ), ( 'S' , 1 )] # 2. Pick a molecule to test molecule = methane # 3. Do stuff to calculate `mol_weight` mol_weight = 0.0 for specie , number in methane : mol_weight += number * atomic_weights [ specie ] print ( mol_weight )","title":"Exercise: How heavy is this molecule?"},{"location":"primer/02_building_logic/solved/Exercises07-WritingFunctions/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Exercises 7: Writing Functions \u00b6 Exercise: Find the first \u00b6 Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in values : if v < 0 : return v Exercise : Running sum \u00b6 Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why? Exercise: How's your phase-change memory? \u00b6 A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"../data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return predicate ( anion ) my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal ))","title":"Exercises07 WritingFunctions"},{"location":"primer/02_building_logic/solved/Exercises07-WritingFunctions/#exercises-7-writing-functions","text":"","title":"Exercises 7: Writing Functions"},{"location":"primer/02_building_logic/solved/Exercises07-WritingFunctions/#exercise-find-the-first","text":"Fill in the blanks to create a function that takes a list of numbers as an argument and returns the first negative value in the list. What does your function do if the list is empty? def first_negative ( values ): for v in values : if v < 0 : return v","title":"Exercise: Find the first"},{"location":"primer/02_building_logic/solved/Exercises07-WritingFunctions/#exercise-running-sum","text":"Write a function that calculates the running sum of any number of input arguments, returning the result as a list. For example: running(1, 2) => [1, 3] running(-5, 2, 7) => [-5, -3, 4] What should running() return, and why?","title":"Exercise : Running sum"},{"location":"primer/02_building_logic/solved/Exercises07-WritingFunctions/#exercise-hows-your-phase-change-memory","text":"A chalcogenide is a chemical compound consisting of at least one chalcogen anion (commonly restricted to \u2018S\u2019, \u2018Se\u2019, or \u2018Te\u2019) and at least one more electropositive element. Generalize the halide function below as compound_class , a function that takes a crystal and function as parameters and returns whether or not the compound is of that class. # %load code/phase_change_memory.py import random from pymatgen import Element import os from monty.serialization import loadfn data_dir = \"../data/\" crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) def halogen ( element ): return element . is_halogen def halide ( crystal ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return halogen ( anion ) def chalcogen ( element ): return element . is_chalogen def compound_class ( crystal , predicate ): elts = [ Element ( s ) for s in crystal [ 'elements' ]] anion = sorted ( elts )[ - 1 ] # sorts by electronegativity return predicate ( anion ) my_crystal = random . sample ( [ c for c in crystals if halide ( c )], 1 )[ 0 ] print ( compound_class ( my_crystal , halogen ) == halide ( my_crystal ))","title":"Exercise: How's your phase-change memory?"},{"location":"primer/02_building_logic/solved/Exercises08-TestYourSkills/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Lesson 8: Test your Skills \u00b6 Now it's time to put your skills to the test! \u00b6 Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"../data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { v : k for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ element_name ][ 'discovered_by' ]: if discoverer in name : elem = Element ( element_symbols [ element_name ]) all_elements . append ( elem ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ 'year' ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 if year_discovered < prior_to : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ elem ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ \"elements\" ], atomic_fractions , weights ): molar_weight += frac * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for elem in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], mass_fractions , abundances ): abundance_metric *= ( 100 * abundance ) ** frac return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) intersection = set ( elements ) & set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( crystal ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( crystal ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : v , \"crystal\" : c } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ \"value\" ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ 'value' ] for x in value_map ] crystals_matched = [ x [ 'crystal' ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ 'pretty_formula' ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , len ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Exercises08 TestYourSkills"},{"location":"primer/02_building_logic/solved/Exercises08-TestYourSkills/#lesson-8-test-your-skills","text":"","title":"Lesson 8: Test your Skills"},{"location":"primer/02_building_logic/solved/Exercises08-TestYourSkills/#now-its-time-to-put-your-skills-to-the-test","text":"Exercise: As a materials investigator, your team has just finished running calculations for a large number of crystal structures. Now, you want to analyze the dataset by writing functions that utilize logic (in the form of conditionals ) to parse through the datasets in the forms of dictionaries and lists . First, load the relevant datasets import os from monty.serialization import loadfn data_dir = \"../data/\" # Our crystal structures, in addition to useful elemental information crystals = loadfn ( os . path . join ( data_dir , \"crystals.json\" )) atomic_numbers = loadfn ( os . path . join ( data_dir , \"atomic_numbers.json\" )) atomic_weights = loadfn ( os . path . join ( data_dir , \"atomic_weights.json\" )) # Names of elements associated with an element symbol (e.g. {\"Al\": \"Aluminium\"}) element_names = loadfn ( os . path . join ( data_dir , \"element_names.json\" )) # Elemental mass fraction of Earth's crust (source: https://en.wikipedia.org/wiki/Abundances_of_the_elements_(data_page)) mass_frac_earth_crust = loadfn ( os . path . join ( data_dir , \"mass_frac_earth_crust.json\" )) # Dictionary of elements, with those who discovered them # and the year they were discovered # (sources: https://en.wikipedia.org/wiki/Timeline_of_chemical_element_discoveries, # https://education.jlab.org/qa/discover_ele.html) discovery_dict = loadfn ( os . path . join ( data_dir , \"discoveries.json\" )) We have the mapping from symbol \\rightarrow \\rightarrow name , now let's obtain name \\rightarrow \\rightarrow symbol (we'll need it later) print ( element_names [ \"Ag\" ]) element_symbols = { v : k for k , v in element_names . items ()} print ( element_symbols [ \"Silver\" ]) Next, we'll choose the set of elements that we would like to start with. Each element has a unique story associated with it. We can explore these stories with the information from the element discovery timeline. Our task: Build a function that takes a list of element symbols as input. In addition, if we want to add the elements associated with a particular materials discoverer, we can include some regex (or \"regular expression\") strings corresponding to the discoverers we would like to feature. from pymatgen.core import Element , Composition def my_element_discoverer ( elements : list = [], discoverers : list = [], prior_to : int = 2020 ): # Start with elements provided by user # (use copy() to not modify list passed to function) all_elements = elements . copy () # Loop through discoverers to find which elements they discovered # and then add them to your list for discoverer in discoverers : for element_name in discovery_dict : for name in discovery_dict [ element_name ][ 'discovered_by' ]: if discoverer in name : elem = Element ( element_symbols [ element_name ]) all_elements . append ( elem ) # Create a new list that will contain only the elements discovered # before the year you provide elements_pruned = [] for elem in all_elements : element_name = element_names [ str ( elem )] if discovery_dict [ element_name ][ 'year' ] != '?' : year_discovered = int ( discovery_dict [ element_name ][ 'year' ]) else : # Unknown discovery date (known since ancient times) year_discovered = - 2000 if year_discovered < prior_to : elem = Element ( elem ) elements_pruned . append ( elem ) all_elements = elements_pruned # Use set() to convert your list into a unique set # then recast as a list() all_elements = list ( set ( all_elements )) return all_elements Let's test out our function! Say we want to use oxygen in addition to elements discovered by scientists with Curie in their name (Marie and Pierre), as well as elements discovered by scientists in Berkeley my_elements = my_element_discoverer ( elements = [ \"O\" ], discoverers = [ \"Curie\" , \"Lawrence Berkeley\" ], prior_to = 2020 ) print ( my_elements ) Can you spot which elements are missing? (Hint below) # Discovered by scientists at UC Berkeley my_elements = my_element_discoverer ( discoverers = [ \"Ghiorso\" ], prior_to = 2020 ) print ( my_elements ) Platinum was found in gold alloys in present day Columbia dating as far back as 800 BC my_elements = my_element_discoverer ( elements = [ \"Ni\" ], discoverers = [ \"Indigenous People of South America\" ], prior_to = 1800 ) print ( my_elements ) Next, our goal is to find all of the crystals that contain the elements in our list. Once we obtain this list, it is often useful to sort these materials based on a particular metric, depending on which properties that we would like to assess. The two criteria we will use in this study are the molar mass and abundance: Molar mass = \\sum_{i=1}^N x_i n_i \\sum_{i=1}^N x_i n_i , where n_i n_i is the elemental molar mass, and x_i x_i is the molar fraction Abundance metric = \\prod_{i=1}^N a_i^{y_i} \\prod_{i=1}^N a_i^{y_i} , where a_i a_i is the mass abundance of the element i i , and y_i y_i is the mass fraction in the material import numpy as np def compute_molar_weight ( crystal ): # Obtain atomic fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) atomic_fractions = [ comp . get_atomic_fraction ( Element ( elem )) for elem in crystal [ 'elements' ]] # Obtain atomic weights of elements in material weights = [ atomic_weights [ elem ] for elem in crystal [ 'elements' ]] # Compute molar weight of material (weighted mean) molar_weight = 0.0 for elem , frac , weight in zip ( crystal [ \"elements\" ], atomic_fractions , weights ): molar_weight += frac * weight return molar_weight def compute_abundance_metric ( crystal ): # Obtain mass fractions of material comp = Composition ( crystal [ \"pretty_formula\" ]) molar_weight = compute_molar_weight ( crystal ) mass_fractions = [ comp . get_atomic_fraction ( Element ( elem )) * ( atomic_weights [ elem ] / molar_weight ) for elem in crystal [ 'elements' ]] # Obtain atomic abundances of elements in material abundances = [ mass_frac_earth_crust [ elem ] for elem in crystal [ 'elements' ]] # Compute abundance metric (geometric mean) abundance_metric = 1.0 for elem , frac , abundance in zip ( crystal [ \"elements\" ], mass_fractions , abundances ): abundance_metric *= ( 100 * abundance ) ** frac return abundance_metric crystal = crystals [ 0 ] print ( \"Material:\" , crystal [ \"pretty_formula\" ]) print ( \"Molar weight (g / mol / # atoms per formula unit) = \" , compute_molar_weight ( crystal )) print ( \"Abundance metric (% kg/kg) = \" , compute_abundance_metric ( crystal )) Now that we have our sorting metrics, let's find the materials in our dataset that contain the elements we have provided, and sort them based on the criteria above. A helpful relation: For finite sets A A and B B , B \\subseteq A B \\subseteq A if and only if B = A \\cap B B = A \\cap B def get_crystals_from_elements ( elements : list , crystals : list , sort_scheme : int = 0 ): crystals_matched = [] for crystal in crystals : crystal_elems = [ Element ( elem ) for elem in crystal [ 'elements' ]] # We can check if the material contains the elements that we have provided # (set B in A) by checking if B = intersection(A,B) intersection = set ( elements ) & set ( crystal_elems ) if set ( elements ) == intersection : crystals_matched . append ( crystal ) if sort_scheme == 0 : # Sort by molar weight sort_key = \"Molar weight (g / mol / # atoms per formula unit)\" sortable_values = [ compute_molar_weight ( crystal ) for crystal in crystals_matched ] elif sort_scheme == 1 : # Sort by abundance metric sort_key = \"Abundance metric (% kg/kg)\" sortable_values = [ compute_abundance_metric ( crystal ) for crystal in crystals_matched ] else : # Catch all case - no sorting provided sortable_values = [] print ( \"Warning: Invalid sort scheme!\" ) return [], [], \"\" if sortable_values : #print(sortable_values) # Sort crystals based on sorting metric (reverse to descending order) value_map = [{ \"value\" : v , \"crystal\" : c } for v , c in zip ( sortable_values , crystals_matched )] value_map = sorted ( value_map , key = lambda x : x [ \"value\" ], reverse = True ) #sortable_values, crystals_matched = zip(*sorted(zip(sortable_values, crystals_matched), reverse=True)) # Extract desired values after sorting sortable_values = [ x [ 'value' ] for x in value_map ] crystals_matched = [ x [ 'crystal' ] for x in value_map ] #print(sortable_values) return crystals_matched , sortable_values , sort_key We've built our functions! Now let's test them to search the materials in our dataset # The elements we would like to search our dataset elements = [ Element ( elem ) for elem in [ 'Ca' , 'O' ]] # Testing our function crystals_matched , sorted_values , sort_key = get_crystals_from_elements ( elements , crystals , sort_scheme = 0 ) # The formulas of the crystals that we searched for formulas = [ crystal [ 'pretty_formula' ] for crystal in crystals_matched ] print ( \"Number of crystals found: \" , len ( crystals_matched )) # print(formulas) For a large number of materials, we often gain the most information by perfoming an analysis of how the sorting criteria is distributed. In this case, we can create a histogram of the data using the matplotlib package. import matplotlib.pyplot as plt number_of_bins = 20 plt . hist ( sorted_values , number_of_bins ) plt . ylabel ( 'Counts' ) plt . xlabel ( sort_key ) plt . show ()","title":"Now it's time to put your skills to the test!"},{"location":"primer/03_MongoDB_part1/exercise_01/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Obtain a document from the laureates collection and display its contents. \u00b6 doc = db . __ . __ ( __ ) doc 3. Obtain a list of tuples containing the first ( \"firstname\" ) and last ( \"surname\" ) name of each laureate in the database who died ( \"diedCountry\" ) in USA. \u00b6 cursor = db . __ . __ ({ __ : __ }) names = [( doc [ __ ], doc [ __ ]) for __ in __ ] names 4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded. \u00b6 cursor = db . __ . __ ( __ ) names = [( doc [ __ ], len ( doc [ __ ])) for __ in __ if len ( doc [ __ ]) > 1 ] names","title":"Exercise 01"},{"location":"primer/03_MongoDB_part1/exercise_01/#intro-to-mongodb-and-the-nobel-prize-dataset-exercise","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_01/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_01/#2-obtain-a-document-from-the-laureates-collection-and-display-its-contents","text":"doc = db . __ . __ ( __ ) doc","title":"2. Obtain a document from the laureates collection and display its contents."},{"location":"primer/03_MongoDB_part1/exercise_01/#3-obtain-a-list-of-tuples-containing-the-first-firstname-and-last-surname-name-of-each-laureate-in-the-database-who-died-diedcountry-in-usa","text":"cursor = db . __ . __ ({ __ : __ }) names = [( doc [ __ ], doc [ __ ]) for __ in __ ] names","title":"3. Obtain a list of tuples containing the first (\"firstname\") and last (\"surname\") name of each laureate in the database who died (\"diedCountry\") in USA."},{"location":"primer/03_MongoDB_part1/exercise_01/#4-did-any-of-the-above-laureates-receive-more-than-one-prize-generate-a-list-of-tuples-with-their-first-name-and-the-total-number-they-were-awarded","text":"cursor = db . __ . __ ( __ ) names = [( doc [ __ ], len ( doc [ __ ])) for __ in __ if len ( doc [ __ ]) > 1 ] names","title":"4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded."},{"location":"primer/03_MongoDB_part1/exercise_02/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Listing and Counting - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Obtain a document from the prizes collection and display its contents. \u00b6 doc = db . __ . __ ( __ ) doc 3. Use count_documents to identify which of the following statements is true? \u00b6 A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . __ . __ ( __ ) num_laureates = db . __ . __ ( __ ) num_laureates / num_prizes Is the number of peace prizes awarded in 1911 ( \"year\" ) larger or smaller than the number of laureates who were born ( \"bornCountry\" ) in Finland? \u00b6 num_prizes = db . __ . __ ({ __ : __ }) num_laureates = db . __ . __ ({ __ : __ }) num_laureates > num_prizes","title":"Exercise 02"},{"location":"primer/03_MongoDB_part1/exercise_02/#listing-and-counting-exercise","text":"","title":"Listing and Counting - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_02/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_02/#2-obtain-a-document-from-the-prizes-collection-and-display-its-contents","text":"doc = db . __ . __ ( __ ) doc","title":"2. Obtain a document from the prizes collection and display its contents."},{"location":"primer/03_MongoDB_part1/exercise_02/#3-use-count_documents-to-identify-which-of-the-following-statements-is-true","text":"A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . __ . __ ( __ ) num_laureates = db . __ . __ ( __ ) num_laureates / num_prizes","title":"3. Use count_documents to identify which of the following statements is true?"},{"location":"primer/03_MongoDB_part1/exercise_02/#is-the-number-of-peace-prizes-awarded-in-1911-year-larger-or-smaller-than-the-number-of-laureates-who-were-born-borncountry-in-finland","text":"num_prizes = db . __ . __ ({ __ : __ }) num_laureates = db . __ . __ ({ __ : __ }) num_laureates > num_prizes","title":"Is the number of peace prizes awarded in 1911 (\"year\") larger or smaller than the number of laureates who were born (\"bornCountry\") in Finland?"},{"location":"primer/03_MongoDB_part1/exercise_03/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Finding, and Dot Notation - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from __ import __ client = __ db = __ . __ print ( db ) 2. Find the total number of laureates who died ( \"diedCountry\" ) in Canada and were not born ( \"bornCountry\" ) in Germany using the $ne operator. \u00b6 criteria = { __ : __ , __ : { __ : __ }} count = db . laureates . count_documents ( criteria ) count 3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes : \u00b6 {'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"1930\" }} count = db . prizes . count_documents ( criteria ) count 4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0 ! \u00b6 criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"2001\" }, \"__.__\" : { __ : True }} count = db . prizes . count_documents ( criteria ) count 5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people. \u00b6 criteria = { __ : __ , __ : { __ : 3 }} count = db . prizes . count_documents ( criteria ) count 6. Estimate the number of laureates who were awarded a prize affiliated with the USA, but were born in a different country. Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates : \u00b6 {'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { __ : { __ : \"USA\" }, \"__.__.__.__.__\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"Exercise 03"},{"location":"primer/03_MongoDB_part1/exercise_03/#finding-and-dot-notation-exercise","text":"","title":"Finding, and Dot Notation - Exercise"},{"location":"primer/03_MongoDB_part1/exercise_03/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from __ import __ client = __ db = __ . __ print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/exercise_03/#2-find-the-total-number-of-laureates-who-died-diedcountry-in-canada-and-were-not-born-borncountry-in-germany-using-the-ne-operator","text":"criteria = { __ : __ , __ : { __ : __ }} count = db . laureates . count_documents ( criteria ) count","title":"2. Find the total number of laureates who died (\"diedCountry\") in Canada and were not born (\"bornCountry\") in Germany using the $ne operator."},{"location":"primer/03_MongoDB_part1/exercise_03/#3-use-the-in-and-gt-operators-to-count-the-total-number-of-physics-and-chemistry-prizes-awarded-after-the-year-1930-recall-the-structure-of-a-document-in-prizes","text":"{'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"1930\" }} count = db . prizes . count_documents ( criteria ) count","title":"3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes:"},{"location":"primer/03_MongoDB_part1/exercise_03/#4-lets-define-high-share-prizes-as-those-shared-by-at-least-three-people-use-dot-notation-and-the-exists-operator-to-find-the-number-of-high-share-physics-and-chemistry-prizes-awarded-after-the-year-2001-remember-arrays-start-with-index-0","text":"criteria = { __ : { __ : [ \"physics\" , \"chemistry\" ]}, __ :{ __ : \"2001\" }, \"__.__\" : { __ : True }} count = db . prizes . count_documents ( criteria ) count","title":"4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0!"},{"location":"primer/03_MongoDB_part1/exercise_03/#5-use-the-size-operator-to-find-the-total-number-of-awarded-peace-prizes-shared-by-exactly-three-people","text":"criteria = { __ : __ , __ : { __ : 3 }} count = db . prizes . count_documents ( criteria ) count","title":"5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people."},{"location":"primer/03_MongoDB_part1/exercise_03/#6-estimate-the-number-of-laureates-who-were-awarded-a-prize-affiliated-with-the-usa-but-were-born-in-a-different-country-use-only-the-first-prize-and-affiliation-in-each-respective-array-recall-the-structure-of-a-document-in-laureates","text":"{'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { __ : { __ : \"USA\" }, \"__.__.__.__.__\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"6. Estimate the number of laureates who were awarded a prize affiliated with the USA, but were born in a different country. Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates:"},{"location":"primer/03_MongoDB_part1/lessons/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Lesson 1 \u00b6 Why MongoDB? \u00b6 - All Materials Project data is stored using MongoDB - Our API query language is based on MongoDB syntax MongoDB Structure \u00b6 - Data objects represented by documents - Documents organized into collections - Collections make up a database Data Structure \u00b6 object \u2192 { field : value , field1 : value1 , ...} fields: string values: string , int/double , true , false , null , array , object , ... example: { name: Sue, age: 28, lawSpecialties: [copyright, tax], canMeet: { mon: True, tues: False, wed: True, thurs: True, fri: False, } } JavaScript Object Notation (JSON) \u00b6 object \u2192 { string : value , string1 : value1 , ...} values: string , number , true , false , null , object , array JSON \\longleftrightarrow \\longleftrightarrow Python \u00b6 objects \u2192 { string : value , string1 : value1 , ...} ---> dictionaries (with str keys) arrays \u2192 [ value , value1 , ...] ---> lists values: string , number , true , false , null , object , array str , int , float , True , False , None , dict , list Accessing MongoDB \u00b6 We can access our MongoDB databases using an instance of MongoClient from the pymongo package. from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) You can access databases and collections as attributes and/or treat them as dictionary keys. client . nobel == client [ \"nobel\" ] True client . nobel . prizes == client [ \"nobel\" ][ \"prizes\" ] True We can also connect to the nobel database. db = client . nobel print ( db ) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel') Searching for documents \u00b6 Let's see what a document looks like in the prizes collection using the find_one() method. This takes an optional filter argument. Passing an empty filter ( {} ) is the same as passing no filter. In Python, the returned document takes the form of a dictionary. The keys of the dictionary are the (root-level) \"fields\" of the document. db . prizes . find_one ({}) {'_id': ObjectId('5f1f4e9430688833f8e30309'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} We can now add a filter to our search to ensure that the returned prizes document contains data for a physics nobel prize. criteria = { \"category\" : \"physics\" } db . prizes . find_one ( criteria ) {'_id': ObjectId('5f1f4e9430688833f8e3030d'), 'year': '2019', 'category': 'physics', 'overallMotivation': '\"for contributions to our understanding of the evolution of the universe and Earth\u2019s place in the cosmos\"', 'laureates': [{'id': '973', 'firstname': 'James', 'surname': 'Peebles', 'motivation': '\"for theoretical discoveries in physical cosmology\"', 'share': '2'}, {'id': '974', 'firstname': 'Michel', 'surname': 'Mayor', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}, {'id': '975', 'firstname': 'Didier', 'surname': 'Queloz', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}]} You may iterate over a collection, collecting from each document. However, a collection is not a list, so we can't write for doc in <collection> to iterate over documents. Instead, we can use the find() method to produce an iterable called a cursor , and instead write for doc in <collection>.find() to iterate over documents. - Using find() to iterate over documents in the laureates collection, sum the total number of laureate prizes. The length of doc[\"prizes\"] for a laureate document doc is the number of prizes won by that laureate. Store the sum in the variable count . # Compute the total number of laureate prizes count = 0 cursor = db . laureates . find ({}) for doc in cursor : num_prizes = len ( doc [ \"prizes\" ]) count += num_prizes count 950 Listing and Counting - Lesson 2 \u00b6 from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Listing databases and collections \u00b6 Recall: - Data objects represented by documents - Documents organized into collections - Collections make up a database We can list database names by calling list_database_names() on a client instance, and we can list collection names by calling list_collection_names() on a database instance. - How many databases are managed by client ? # Save a list of names of the databases managed by client db_names = client . list_database_names () print ( db_names ) # Save a list of names of the collections managed by the \"nobel\" database nobel_coll_names = client . nobel . list_collection_names () print ( nobel_coll_names ) ['admin', 'config', 'drone_test', 'fireworks', 'local', 'maggma_test', 'mp_workshop', 'nobel'] ['prizes', 'laureates'] Counting documents \u00b6 # Connect to our \"nobel\" database db = client . nobel The count_documents() method of a collection can be used to count the number of documents matching a particular filter. Let's use the method to count the total number of nobel laureates who died in the USA. An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} db . laureates . count_documents ({ \"diedCountry\" : \"USA\" }) 222 We can now build out our filter to reduce the total number of matching documents: Create a filter criteria to count the number of laureates who died in the USA but were born ( \"bornCountry\" ) in Germany. # Create a filter for laureates who died in the USA but were born in Germany criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" } # Save a count count = db . laureates . count_documents ( criteria ) print ( count ) 5 - Count laureates who died in the USA, were born in Germany, and whose first name ( \"firstname\" ) was \"Albert\". # Create a filter for laureates who died in the USA, were born in Germany, and whose first name was Albert. criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" , \"firstname\" : \"Albert\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1ccead'), 'id': '26', 'firstname': 'Albert', 'surname': 'Einstein', 'born': '1879-03-14', 'died': '1955-04-18', 'bornCountry': 'Germany', 'bornCountryCode': 'DE', 'bornCity': 'Ulm', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Princeton, NJ', 'gender': 'male', 'prizes': [{'year': '1921', 'category': 'physics', 'share': '1', 'motivation': '\"for his services to Theoretical Physics, and especially for his discovery of the law of the photoelectric effect\"', 'affiliations': [{'name': 'Kaiser-Wilhelm-Institut (now Max-Planck-Institut) f\u00fcr Physik', 'city': 'Berlin', 'country': 'Germany'}]}]} Finding, and Dot Notation - Lesson 3 \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( client ) print ( db ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel') Query operators \u00b6 Query operators provide us more options when constructing filters. For example, we may wish to find documents where a field's value matches any of a set of options. To do this we can use the $in query operator. - How many laureates were born in any of \"Canada\", \"Mexico\", or \"USA\"? #Save a filter for laureates who were born in with Canada, Mexico, or the USA. criteria = { \"bornCountry\" : { \"$in\" : [ \"Canada\" , \"Mexico\" , \"USA\" ]}} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 295 If we wish to accept all but one option as a value for a field, we can use the $ne ( n ot e qual) operator. - How many laureates died in the USA but were not born in the USA? # Save a filter for laureates who died in the USA and were not born there. criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"diedCountry\" : \"USA\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 71 Below is a list of comparison query operators that are available in MongoDB: $eq -- Matches values that are equal to a specified value. $gt -- Matches values that are greater than a specified value. $gte -- Matches values that are greater than or equal to a specified value. $in -- Matches any of the values specified in an array. $lt -- Matches values that are less than a specified value. $lte -- Matches values that are less than or equal to a specified value. $ne -- Matches all values that are not equal to a specified value. $nin -- Matches none of the values specified in an array. In addition to comparison query operators, we can use logical query operators in our filters as well. - How many laureates died in Canada OR were born in France? #Save a filter for laureates who were born in Canada OR died in France. criteria = { \"$or\" :[{ \"diedCountry\" : \"Canada\" }, { \"bornCountry\" : \"France\" }]} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 59 Below is a list of logical query operators that are available in MongoDB: $and -- Joins query clauses with a logical AND returns all documents that match the conditions of both clauses. $not -- Inverts the effect of a query expression and returns documents that do not match the query expression. $nor -- Joins query clauses with a logical NOR returns all documents that fail to match both clauses. $or -- Joins query clauses with a logical OR returns all documents that match the conditions of either clause. See https://docs.mongodb.com/manual/reference/operator/query/ for more operators! Using dot notation \u00b6 You will notice that the prizes field of a laureates document consists of an array of subdocuments: An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} An easy way to construct filters for array entries or subdocument fields is to use dot notation. - Use the $exists operator to find out how many laureates were awarded at least two prizes? #Save a filter for laureates who were awarded at least two prizes. criteria = { \"prizes.1\" :{ \"$exists\" : True }} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 6 - Estimate how many laureates were awarded at least two prizes in physics specifically? #Save a filter to estimate the number of laureates who were awarded at least two prizes in physics. criteria = { \"prizes.0.category\" : \"physics\" , \"prizes.1.category\" : \"physics\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1cced5'), 'id': '66', 'firstname': 'John', 'surname': 'Bardeen', 'born': '1908-05-23', 'died': '1991-01-30', 'bornCountry': 'USA', 'bornCountryCode': 'US', 'bornCity': 'Madison, WI', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Boston, MA', 'gender': 'male', 'prizes': [{'year': '1956', 'category': 'physics', 'share': '3', 'motivation': '\"for their researches on semiconductors and their discovery of the transistor effect\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}, {'year': '1972', 'category': 'physics', 'share': '3', 'motivation': '\"for their jointly developed theory of superconductivity, usually called the BCS-theory\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}]}","title":"Intro to MongoDB"},{"location":"primer/03_MongoDB_part1/lessons/#intro-to-mongodb-and-the-nobel-prize-dataset-lesson-1","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Lesson 1"},{"location":"primer/03_MongoDB_part1/lessons/#why-mongodb","text":"- All Materials Project data is stored using MongoDB - Our API query language is based on MongoDB syntax","title":"Why MongoDB?"},{"location":"primer/03_MongoDB_part1/lessons/#mongodb-structure","text":"- Data objects represented by documents - Documents organized into collections - Collections make up a database","title":"MongoDB Structure"},{"location":"primer/03_MongoDB_part1/lessons/#data-structure","text":"object \u2192 { field : value , field1 : value1 , ...} fields: string values: string , int/double , true , false , null , array , object , ... example: { name: Sue, age: 28, lawSpecialties: [copyright, tax], canMeet: { mon: True, tues: False, wed: True, thurs: True, fri: False, } }","title":"Data Structure"},{"location":"primer/03_MongoDB_part1/lessons/#javascript-object-notation-json","text":"object \u2192 { string : value , string1 : value1 , ...} values: string , number , true , false , null , object , array","title":"JavaScript Object Notation (JSON)"},{"location":"primer/03_MongoDB_part1/lessons/#json-longleftrightarrowlongleftrightarrow-python","text":"objects \u2192 { string : value , string1 : value1 , ...} ---> dictionaries (with str keys) arrays \u2192 [ value , value1 , ...] ---> lists values: string , number , true , false , null , object , array str , int , float , True , False , None , dict , list","title":"JSON \\longleftrightarrow\\longleftrightarrow Python"},{"location":"primer/03_MongoDB_part1/lessons/#accessing-mongodb","text":"We can access our MongoDB databases using an instance of MongoClient from the pymongo package. from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) You can access databases and collections as attributes and/or treat them as dictionary keys. client . nobel == client [ \"nobel\" ] True client . nobel . prizes == client [ \"nobel\" ][ \"prizes\" ] True We can also connect to the nobel database. db = client . nobel print ( db ) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel')","title":"Accessing MongoDB"},{"location":"primer/03_MongoDB_part1/lessons/#searching-for-documents","text":"Let's see what a document looks like in the prizes collection using the find_one() method. This takes an optional filter argument. Passing an empty filter ( {} ) is the same as passing no filter. In Python, the returned document takes the form of a dictionary. The keys of the dictionary are the (root-level) \"fields\" of the document. db . prizes . find_one ({}) {'_id': ObjectId('5f1f4e9430688833f8e30309'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} We can now add a filter to our search to ensure that the returned prizes document contains data for a physics nobel prize. criteria = { \"category\" : \"physics\" } db . prizes . find_one ( criteria ) {'_id': ObjectId('5f1f4e9430688833f8e3030d'), 'year': '2019', 'category': 'physics', 'overallMotivation': '\"for contributions to our understanding of the evolution of the universe and Earth\u2019s place in the cosmos\"', 'laureates': [{'id': '973', 'firstname': 'James', 'surname': 'Peebles', 'motivation': '\"for theoretical discoveries in physical cosmology\"', 'share': '2'}, {'id': '974', 'firstname': 'Michel', 'surname': 'Mayor', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}, {'id': '975', 'firstname': 'Didier', 'surname': 'Queloz', 'motivation': '\"for the discovery of an exoplanet orbiting a solar-type star\"', 'share': '4'}]} You may iterate over a collection, collecting from each document. However, a collection is not a list, so we can't write for doc in <collection> to iterate over documents. Instead, we can use the find() method to produce an iterable called a cursor , and instead write for doc in <collection>.find() to iterate over documents. - Using find() to iterate over documents in the laureates collection, sum the total number of laureate prizes. The length of doc[\"prizes\"] for a laureate document doc is the number of prizes won by that laureate. Store the sum in the variable count . # Compute the total number of laureate prizes count = 0 cursor = db . laureates . find ({}) for doc in cursor : num_prizes = len ( doc [ \"prizes\" ]) count += num_prizes count 950","title":"Searching for documents"},{"location":"primer/03_MongoDB_part1/lessons/#listing-and-counting-lesson-2","text":"from pymongo import MongoClient client = MongoClient () print ( client ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True)","title":"Listing and Counting - Lesson 2"},{"location":"primer/03_MongoDB_part1/lessons/#listing-databases-and-collections","text":"Recall: - Data objects represented by documents - Documents organized into collections - Collections make up a database We can list database names by calling list_database_names() on a client instance, and we can list collection names by calling list_collection_names() on a database instance. - How many databases are managed by client ? # Save a list of names of the databases managed by client db_names = client . list_database_names () print ( db_names ) # Save a list of names of the collections managed by the \"nobel\" database nobel_coll_names = client . nobel . list_collection_names () print ( nobel_coll_names ) ['admin', 'config', 'drone_test', 'fireworks', 'local', 'maggma_test', 'mp_workshop', 'nobel'] ['prizes', 'laureates']","title":"Listing databases and collections"},{"location":"primer/03_MongoDB_part1/lessons/#counting-documents","text":"# Connect to our \"nobel\" database db = client . nobel The count_documents() method of a collection can be used to count the number of documents matching a particular filter. Let's use the method to count the total number of nobel laureates who died in the USA. An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} db . laureates . count_documents ({ \"diedCountry\" : \"USA\" }) 222 We can now build out our filter to reduce the total number of matching documents: Create a filter criteria to count the number of laureates who died in the USA but were born ( \"bornCountry\" ) in Germany. # Create a filter for laureates who died in the USA but were born in Germany criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" } # Save a count count = db . laureates . count_documents ( criteria ) print ( count ) 5 - Count laureates who died in the USA, were born in Germany, and whose first name ( \"firstname\" ) was \"Albert\". # Create a filter for laureates who died in the USA, were born in Germany, and whose first name was Albert. criteria = { \"diedCountry\" : \"USA\" , \"bornCountry\" : \"Germany\" , \"firstname\" : \"Albert\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1ccead'), 'id': '26', 'firstname': 'Albert', 'surname': 'Einstein', 'born': '1879-03-14', 'died': '1955-04-18', 'bornCountry': 'Germany', 'bornCountryCode': 'DE', 'bornCity': 'Ulm', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Princeton, NJ', 'gender': 'male', 'prizes': [{'year': '1921', 'category': 'physics', 'share': '1', 'motivation': '\"for his services to Theoretical Physics, and especially for his discovery of the law of the photoelectric effect\"', 'affiliations': [{'name': 'Kaiser-Wilhelm-Institut (now Max-Planck-Institut) f\u00fcr Physik', 'city': 'Berlin', 'country': 'Germany'}]}]}","title":"Counting documents"},{"location":"primer/03_MongoDB_part1/lessons/#finding-and-dot-notation-lesson-3","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( client ) print ( db ) MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True) Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'nobel')","title":"Finding, and Dot Notation - Lesson 3"},{"location":"primer/03_MongoDB_part1/lessons/#query-operators","text":"Query operators provide us more options when constructing filters. For example, we may wish to find documents where a field's value matches any of a set of options. To do this we can use the $in query operator. - How many laureates were born in any of \"Canada\", \"Mexico\", or \"USA\"? #Save a filter for laureates who were born in with Canada, Mexico, or the USA. criteria = { \"bornCountry\" : { \"$in\" : [ \"Canada\" , \"Mexico\" , \"USA\" ]}} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 295 If we wish to accept all but one option as a value for a field, we can use the $ne ( n ot e qual) operator. - How many laureates died in the USA but were not born in the USA? # Save a filter for laureates who died in the USA and were not born there. criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"diedCountry\" : \"USA\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 71 Below is a list of comparison query operators that are available in MongoDB: $eq -- Matches values that are equal to a specified value. $gt -- Matches values that are greater than a specified value. $gte -- Matches values that are greater than or equal to a specified value. $in -- Matches any of the values specified in an array. $lt -- Matches values that are less than a specified value. $lte -- Matches values that are less than or equal to a specified value. $ne -- Matches all values that are not equal to a specified value. $nin -- Matches none of the values specified in an array. In addition to comparison query operators, we can use logical query operators in our filters as well. - How many laureates died in Canada OR were born in France? #Save a filter for laureates who were born in Canada OR died in France. criteria = { \"$or\" :[{ \"diedCountry\" : \"Canada\" }, { \"bornCountry\" : \"France\" }]} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 59 Below is a list of logical query operators that are available in MongoDB: $and -- Joins query clauses with a logical AND returns all documents that match the conditions of both clauses. $not -- Inverts the effect of a query expression and returns documents that do not match the query expression. $nor -- Joins query clauses with a logical NOR returns all documents that fail to match both clauses. $or -- Joins query clauses with a logical OR returns all documents that match the conditions of either clause. See https://docs.mongodb.com/manual/reference/operator/query/ for more operators!","title":"Query operators"},{"location":"primer/03_MongoDB_part1/lessons/#using-dot-notation","text":"You will notice that the prizes field of a laureates document consists of an array of subdocuments: An example laureates document: {'_id': ObjectId('5b9ac94ff35b63cf5231ccb1'), 'born': '1845-03-27', 'bornCity': 'Lennep (now Remscheid)', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'died': '1923-02-10', 'diedCity': 'Munich', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'firstname': 'Wilhelm Conrad', 'gender': 'male', 'id': '1', 'prizes': [{'affiliations': [{'city': 'Munich', 'country': 'Germany', 'name': 'Munich University'}], 'category': 'physics', 'motivation': '\"in recognition of the extraordinary services ' 'he has rendered by the discovery of the ' 'remarkable rays subsequently named after him\"', 'share': '1', 'year': '1901'}], 'surname': 'R\u00f6ntgen'} An easy way to construct filters for array entries or subdocument fields is to use dot notation. - Use the $exists operator to find out how many laureates were awarded at least two prizes? #Save a filter for laureates who were awarded at least two prizes. criteria = { \"prizes.1\" :{ \"$exists\" : True }} # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 6 - Estimate how many laureates were awarded at least two prizes in physics specifically? #Save a filter to estimate the number of laureates who were awarded at least two prizes in physics. criteria = { \"prizes.0.category\" : \"physics\" , \"prizes.1.category\" : \"physics\" } # Count them and save the count. count = db . laureates . count_documents ( criteria ) print ( count ) 1 db . laureates . find_one ( criteria ) {'_id': ObjectId('5f1f4e418defad6d9f1cced5'), 'id': '66', 'firstname': 'John', 'surname': 'Bardeen', 'born': '1908-05-23', 'died': '1991-01-30', 'bornCountry': 'USA', 'bornCountryCode': 'US', 'bornCity': 'Madison, WI', 'diedCountry': 'USA', 'diedCountryCode': 'US', 'diedCity': 'Boston, MA', 'gender': 'male', 'prizes': [{'year': '1956', 'category': 'physics', 'share': '3', 'motivation': '\"for their researches on semiconductors and their discovery of the transistor effect\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}, {'year': '1972', 'category': 'physics', 'share': '3', 'motivation': '\"for their jointly developed theory of superconductivity, usually called the BCS-theory\"', 'affiliations': [{'name': 'University of Illinois', 'city': 'Urbana, IL', 'country': 'USA'}]}]}","title":"Using dot notation"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Intro to MongoDB and the Nobel Prize Dataset - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Obtain a document from the laureates collection and display its contents. \u00b6 doc = db . laureates . find_one ({}) doc Obtain a list of field values for this document that have a string value. \u00b6 fields = [ field for field in doc if type ( doc [ field ]) is str ] fields 3. Obtain a list of tuples containing the first and last name of each laureate in the database who died in USA. i.e. (FirstName, LastName) \u00b6 cursor = db . laureates . find ({ \"diedCountry\" : \"USA\" }) names = [( doc [ \"firstname\" ], doc [ \"surname\" ]) for doc in cursor ] names 4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded. \u00b6 cursor = db . laureates . find ({}) names = [( doc [ \"firstname\" ], len ( doc [ \"prizes\" ])) for doc in cursor if len ( doc [ \"prizes\" ]) > 1 ] names","title":"Exercise 01 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#intro-to-mongodb-and-the-nobel-prize-dataset-exercise","text":"","title":"Intro to MongoDB and the Nobel Prize Dataset - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#2-obtain-a-document-from-the-laureates-collection-and-display-its-contents","text":"doc = db . laureates . find_one ({}) doc","title":"2. Obtain a document from the laureates collection and display its contents."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#obtain-a-list-of-field-values-for-this-document-that-have-a-string-value","text":"fields = [ field for field in doc if type ( doc [ field ]) is str ] fields","title":"Obtain a list of field values for this document that have a string value."},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#3-obtain-a-list-of-tuples-containing-the-first-and-last-name-of-each-laureate-in-the-database-who-died-in-usa-ie-firstname-lastname","text":"cursor = db . laureates . find ({ \"diedCountry\" : \"USA\" }) names = [( doc [ \"firstname\" ], doc [ \"surname\" ]) for doc in cursor ] names","title":"3. Obtain a list of tuples containing the first and last name of each laureate in the database who died in USA. i.e. (FirstName, LastName)"},{"location":"primer/03_MongoDB_part1/solved/exercise_01_solved/#4-did-any-of-the-above-laureates-receive-more-than-one-prize-generate-a-list-of-tuples-with-their-first-name-and-the-total-number-they-were-awarded","text":"cursor = db . laureates . find ({}) names = [( doc [ \"firstname\" ], len ( doc [ \"prizes\" ])) for doc in cursor if len ( doc [ \"prizes\" ]) > 1 ] names","title":"4. Did any of the above laureates receive more than one prize? Generate a list of tuples with their first name and the total number they were awarded."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Listing and Counting - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Obtain a document from the prizes collection and display its contents. \u00b6 doc = db . prizes . find_one ({}) doc 3. Use count_documents to identify which of the following statements is true? \u00b6 A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . prizes . count_documents ({}) num_laureates = db . laureates . count_documents ({}) num_laureates / num_prizes # D is correct. Is the number of peace prizes awarded in 1911 larger or smaller than the number of laureates who were born ( \"bornCountry\" ) in Finland? \u00b6 num_prizes = db . prizes . count_documents ({ \"year\" : \"1911\" }) num_laureates = db . laureates . count_documents ({ \"bornCountry\" : \"Finland\" }) num_laureates > num_prizes","title":"Exercise 02 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#listing-and-counting-exercise","text":"","title":"Listing and Counting - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#2-obtain-a-document-from-the-prizes-collection-and-display-its-contents","text":"doc = db . prizes . find_one ({}) doc","title":"2. Obtain a document from the prizes collection and display its contents."},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#3-use-count_documents-to-identify-which-of-the-following-statements-is-true","text":"A. the number of prizes and laureates are equal B. prizes outnumber laureates by < 2x C. prizes outnumber laureates by > 2x D. laureates outnumber prizes by < 2x E. laureates outnumber prizes by > 2x num_prizes = db . prizes . count_documents ({}) num_laureates = db . laureates . count_documents ({}) num_laureates / num_prizes # D is correct.","title":"3. Use count_documents to identify which of the following statements is true?"},{"location":"primer/03_MongoDB_part1/solved/exercise_02_solved/#is-the-number-of-peace-prizes-awarded-in-1911-larger-or-smaller-than-the-number-of-laureates-who-were-born-borncountry-in-finland","text":"num_prizes = db . prizes . count_documents ({ \"year\" : \"1911\" }) num_laureates = db . laureates . count_documents ({ \"bornCountry\" : \"Finland\" }) num_laureates > num_prizes","title":"Is the number of peace prizes awarded in 1911 larger or smaller than the number of laureates who were born (\"bornCountry\") in Finland?"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); Finding, and Dot Notation - Exercise \u00b6 1. Instantiate MongoClient and connect to the to the nobel database. \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db ) 2. Find the total number of laureates who died ( \"diedCountry\" ) in Canada and were not born in Germany using the $ne operator. \u00b6 criteria = { \"diedCountry\" : \"Canada\" , \"bornCountry\" : { \"$ne\" : \"Germany\" }} count = db . laureates . count_documents ( criteria ) count 3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes : \u00b6 {'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"1930\" }} count = db . prizes . count_documents ( criteria ) count 4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0 ! \u00b6 criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"2001\" }, \"laureates.2\" : { \"$exists\" : True }} count = db . prizes . count_documents ( criteria ) count 5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people. \u00b6 criteria = { \"category\" : \"peace\" , \"laureates\" : { \"$size\" : 3 }} count = db . prizes . count_documents ( criteria ) count 6. Estimate the number of laureates who were awarded a prize ( \"prizes\" ) affiliated with the USA, but were born in a different country ( \"bornCountry\" ). Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates : \u00b6 {'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"prizes.0.affiliations.0.country\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"Exercise 03 solved"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#finding-and-dot-notation-exercise","text":"","title":"Finding, and Dot Notation - Exercise"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#1-instantiate-mongoclient-and-connect-to-the-to-the-nobel-database","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel print ( db )","title":"1. Instantiate MongoClient and connect to the to the nobel database."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#2-find-the-total-number-of-laureates-who-died-diedcountry-in-canada-and-were-not-born-in-germany-using-the-ne-operator","text":"criteria = { \"diedCountry\" : \"Canada\" , \"bornCountry\" : { \"$ne\" : \"Germany\" }} count = db . laureates . count_documents ( criteria ) count","title":"2. Find the total number of laureates who died (\"diedCountry\") in Canada and were not born in Germany using the $ne operator."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#3-use-the-in-and-gt-operators-to-count-the-total-number-of-physics-and-chemistry-prizes-awarded-after-the-year-1930-recall-the-structure-of-a-document-in-prizes","text":"{'_id': ObjectId('5f1746222466f220f494d00c'), 'year': '2019', 'category': 'chemistry', 'laureates': [{'id': '976', 'firstname': 'John', 'surname': 'Goodenough', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '977', 'firstname': 'M. Stanley', 'surname': 'Whittingham', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}, {'id': '978', 'firstname': 'Akira', 'surname': 'Yoshino', 'motivation': '\"for the development of lithium-ion batteries\"', 'share': '3'}]} criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"1930\" }} count = db . prizes . count_documents ( criteria ) count","title":"3. Use the $in and $gt operators to count the total number of physics and chemistry prizes awarded after the year 1930. Recall the structure of a document in prizes:"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#4-lets-define-high-share-prizes-as-those-shared-by-at-least-three-people-use-dot-notation-and-the-exists-operator-to-find-the-number-of-high-share-physics-and-chemistry-prizes-awarded-after-the-year-2001-remember-arrays-start-with-index-0","text":"criteria = { \"category\" : { \"$in\" : [ \"physics\" , \"chemistry\" ]}, \"year\" :{ \"$gt\" : \"2001\" }, \"laureates.2\" : { \"$exists\" : True }} count = db . prizes . count_documents ( criteria ) count","title":"4. Let's define \"high-share\" prizes as those shared by at least three people. Use dot notation and the $exists operator to find the number of \"high-share\" physics and chemistry prizes awarded after the year 2001. Remember arrays start with index 0!"},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#5-use-the-size-operator-to-find-the-total-number-of-awarded-peace-prizes-shared-by-exactly-three-people","text":"criteria = { \"category\" : \"peace\" , \"laureates\" : { \"$size\" : 3 }} count = db . prizes . count_documents ( criteria ) count","title":"5. Use the $size operator to find the total number of awarded peace prizes shared by exactly three people."},{"location":"primer/03_MongoDB_part1/solved/exercise_03_solved/#6-estimate-the-number-of-laureates-who-were-awarded-a-prize-prizes-affiliated-with-the-usa-but-were-born-in-a-different-country-borncountry-use-only-the-first-prize-and-affiliation-in-each-respective-array-recall-the-structure-of-a-document-in-laureates","text":"{'_id': ObjectId('5f1746222466f220f494d292'), 'id': '1', 'firstname': 'Wilhelm Conrad', 'surname': 'R\u00f6ntgen', 'born': '1845-03-27', 'died': '1923-02-10', 'bornCountry': 'Prussia (now Germany)', 'bornCountryCode': 'DE', 'bornCity': 'Lennep (now Remscheid)', 'diedCountry': 'Germany', 'diedCountryCode': 'DE', 'diedCity': 'Munich', 'gender': 'male', 'prizes': [{'year': '1901', 'category': 'physics', 'share': '1', 'motivation': '\"in recognition of the extraordinary services he has rendered by the discovery of the remarkable rays subsequently named after him\"', 'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]} criteria = { \"bornCountry\" : { \"$ne\" : \"USA\" }, \"prizes.0.affiliations.0.country\" : \"USA\" } count = db . laureates . count_documents ( criteria ) count","title":"6. Estimate the number of laureates who were awarded a prize (\"prizes\") affiliated with the USA, but were born in a different country (\"bornCountry\"). Use only the first prize and affiliation in each respective array. Recall the structure of a document in laureates:"},{"location":"primer/04_MongoDB_part2/exercises/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 Exercises \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel Never from there, but sometimes there at last \u00b6 There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( ____ ) - set ( ____ ) print ( countries ) Countries of affiliation \u00b6 We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = ____ ( db . laureates . ____ ( ____ )) print ( count ) Triple plays (mostly) all around \u00b6 All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { ____ : { ____ : ____ }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = ____ ( db . prizes . distinct ( ____ , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( ____ )) - triple_play_categories == { ____ } Other sharing after World War II \u00b6 Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { ____ : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { ____ : \"1\" }, \"year\" : { ____ : \"1945\" }, }}} ratio = db . laureates . ____ ( ____ ) / db . laureates . ____ ( ____ ) print ( ratio ) Organizations and prizes over time \u00b6 How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { ____ : ____ , ____ : { ____ : \"1945\" }, } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { ____ : ____ , ____ : { ____ : \"1945\" }, } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio ) Germany, then and now \u00b6 Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { ____ : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { ____ : \"^\" + ____ + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { ____ : \"now\" + ____ + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) The prized transistor \u00b6 Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { ____ : { ____ : ____ }} # Save the field names corresponding to a laureate's first name and last name first , last = ____ , ____ print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )]) 2: Projection and Sorting \u00b6 Rounding up the G.S. crew \u00b6 We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ ____ ], doc [ ____ ]]) for doc in db . laureates . find ( { ____ : { \"$regex\" : \"^G\" }, ____ : { \"$regex\" : \"^S\" }}, { ____ : 1 , ____ : 1 })] print ( names ) Sorting together: MongoDB + Python \u00b6 You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( ____ , ____ )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ , ____ : { ____ : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ ____ ], key = itemgetter ( ____ ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line ) Gap years \u00b6 As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . ____ ( \"category\" , { ____ : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . ____ ({ \"category\" : { ____ : list ( original_categories )}, ____ : { ____ : ____ }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( ____ , ____ ), ( ____ , ____ )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ ____ ] for prize in group ) missing = \", \" . join ( sorted ( ____ - ____ )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line ) 3: Indexing \u00b6 An index for high-share categories \u00b6 We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( ____ , ____ ), ( ____ , ____ )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. # Drop the index for consistency db . prizes . drop_index ( index_model ) Recently single? \u00b6 A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( ____ , 1 ), ( ____ , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . ____ ( \"category\" )): doc = db . prizes . find_one ( { ____ : ____ , \"laureates.share\" : \"1\" }, sort = [( ____ , ____ )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model ) Born and affiliated \u00b6 Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( ____ , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ ____ : ____ , \"prizes.affiliations.country\" : ____ }) for ____ in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( ____ , 1 )])","title":"Exercises"},{"location":"primer/04_MongoDB_part2/exercises/#mongodb-part-2-exercises","text":"","title":"MongoDB Part 2 Exercises"},{"location":"primer/04_MongoDB_part2/exercises/#1-working-with-distinct-values-elemmatch-and-regex","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/exercises/#never-from-there-but-sometimes-there-at-last","text":"There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( ____ ) - set ( ____ ) print ( countries )","title":"Never from there, but sometimes there at last"},{"location":"primer/04_MongoDB_part2/exercises/#countries-of-affiliation","text":"We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = ____ ( db . laureates . ____ ( ____ )) print ( count )","title":"Countries of affiliation"},{"location":"primer/04_MongoDB_part2/exercises/#triple-plays-mostly-all-around","text":"All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { ____ : { ____ : ____ }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = ____ ( db . prizes . distinct ( ____ , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( ____ )) - triple_play_categories == { ____ }","title":"Triple plays (mostly) all around"},{"location":"primer/04_MongoDB_part2/exercises/#other-sharing-after-world-war-ii","text":"Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { ____ : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { ____ : { ____ : { ____ : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { ____ : \"1\" }, \"year\" : { ____ : \"1945\" }, }}} ratio = db . laureates . ____ ( ____ ) / db . laureates . ____ ( ____ ) print ( ratio )","title":"Other sharing after World War II"},{"location":"primer/04_MongoDB_part2/exercises/#organizations-and-prizes-over-time","text":"How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { ____ : ____ , ____ : { ____ : \"1945\" }, } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { ____ : ____ , ____ : { ____ : \"1945\" }, } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio )","title":"Organizations and prizes over time"},{"location":"primer/04_MongoDB_part2/exercises/#germany-then-and-now","text":"Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { ____ : ____ }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { ____ : \"^\" + ____ + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { ____ : \"now\" + ____ + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria )))","title":"Germany, then and now"},{"location":"primer/04_MongoDB_part2/exercises/#the-prized-transistor","text":"Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { ____ : { ____ : ____ }} # Save the field names corresponding to a laureate's first name and last name first , last = ____ , ____ print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )])","title":"The prized transistor"},{"location":"primer/04_MongoDB_part2/exercises/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/exercises/#rounding-up-the-gs-crew","text":"We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ ____ ], doc [ ____ ]]) for doc in db . laureates . find ( { ____ : { \"$regex\" : \"^G\" }, ____ : { \"$regex\" : \"^S\" }}, { ____ : 1 , ____ : 1 })] print ( names )","title":"Rounding up the G.S. crew"},{"location":"primer/04_MongoDB_part2/exercises/#sorting-together-mongodb-python","text":"You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( ____ , ____ )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . ____ ({ ____ : ____ , ____ : { ____ : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ ____ ], key = itemgetter ( ____ ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line )","title":"Sorting together: MongoDB + Python"},{"location":"primer/04_MongoDB_part2/exercises/#gap-years","text":"As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . ____ ( \"category\" , { ____ : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . ____ ({ \"category\" : { ____ : list ( original_categories )}, ____ : { ____ : ____ }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( ____ , ____ ), ( ____ , ____ )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ ____ ] for prize in group ) missing = \", \" . join ( sorted ( ____ - ____ )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line )","title":"Gap years"},{"location":"primer/04_MongoDB_part2/exercises/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/exercises/#an-index-for-high-share-categories","text":"We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( ____ , ____ ), ( ____ , ____ )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"An index for high-share categories"},{"location":"primer/04_MongoDB_part2/exercises/#recently-single","text":"A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( ____ , 1 ), ( ____ , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . ____ ( \"category\" )): doc = db . prizes . find_one ( { ____ : ____ , \"laureates.share\" : \"1\" }, sort = [( ____ , ____ )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"Recently single?"},{"location":"primer/04_MongoDB_part2/exercises/#born-and-affiliated","text":"Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( ____ , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ ____ : ____ , \"prizes.affiliations.country\" : ____ }) for ____ in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( ____ , 1 )])","title":"Born and affiliated"},{"location":"primer/04_MongoDB_part2/exercises_solved/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 Exercise Solutions \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel Never from there, but sometimes there at last \u00b6 There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( db . laureates . distinct ( \"diedCountry\" )) - set ( db . laureates . distinct ( \"bornCountry\" )) print ( countries ) Countries of affiliation \u00b6 We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = len ( db . laureates . distinct ( \"prizes.affiliations.country\" )) print ( count ) Triple plays (mostly) all around \u00b6 All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { \"laureates.2\" : { \"$exists\" : True }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = set ( db . prizes . distinct ( \"category\" , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( \"category\" )) - triple_play_categories == { \"literature\" } Other sharing after World War II \u00b6 Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { \"$gt\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gt\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) Organizations and prizes over time \u00b6 How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { \"gender\" : \"org\" , \"prizes.year\" : { \"$lt\" : \"1945\" } } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { \"gender\" : \"org\" , \"prizes.year\" : { \"$gte\" : \"1945\" } } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio ) Germany, then and now \u00b6 Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : \"Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { \"$regex\" : \"^Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { \"$regex\" : \"^\" + \"Germany \\(\" + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { \"$regex\" : \"now\" + \" Germany\\)\" + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) The prized transistor \u00b6 Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { \"prizes.motivation\" : { \"$regex\" : \"transistor\" }} # Save the field names corresponding to a laureate's first name and last name first , last = \"firstname\" , \"surname\" print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )]) 2: Projection and Sorting \u00b6 Rounding up the G.S. crew \u00b6 We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ \"firstname\" ], doc [ \"surname\" ]]) for doc in db . laureates . find ( { \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}, { \"firstname\" : 1 , \"surname\" : 1 })] print ( names ) Sorting together: MongoDB + Python \u00b6 You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( \"year\" , 1 )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" , \"laureates\" : { \"$exists\" : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ \"laureates\" ], key = itemgetter ( \"surname\" ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line ) Gap years \u00b6 As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . distinct ( \"category\" , { \"year\" : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . find ({ \"category\" : { \"$in\" : list ( original_categories )}, \"laureates\" : { \"$exists\" : True }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( \"year\" , - 1 ), ( \"category\" , 1 )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ \"category\" ] for prize in group ) missing = \", \" . join ( sorted ( original_categories - year_categories )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line ) 3: Indexing \u00b6 An index for high-share categories \u00b6 We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( \"laureates.share\" , 1 ), ( \"category\" , 1 )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) # Drop the index for consistency db . prizes . drop_index ( index_model ) Recently single? \u00b6 A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( \"category\" , 1 ), ( \"year\" , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . distinct ( \"category\" )): doc = db . prizes . find_one ( { \"category\" : category , \"laureates.share\" : \"1\" }, sort = [( \"year\" , - 1 )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model ) Born and affiliated \u00b6 Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( \"bornCountry\" , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ \"bornCountry\" : country , \"prizes.affiliations.country\" : country }) for country in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( \"bornCountry\" , 1 )])","title":"Exercises solved"},{"location":"primer/04_MongoDB_part2/exercises_solved/#mongodb-part-2-exercise-solutions","text":"","title":"MongoDB Part 2 Exercise Solutions"},{"location":"primer/04_MongoDB_part2/exercises_solved/#1-working-with-distinct-values-elemmatch-and-regex","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/exercises_solved/#never-from-there-but-sometimes-there-at-last","text":"There are some recorded countries of death ( \"diedCountry\" ) that do not appear as a country of birth ( \"bornCountry\" ) for laureates. One such country is \"East Germany\". Return a set of all such countries as countries . # Countries recorded as countries of death but not as countries of birth countries = set ( db . laureates . distinct ( \"diedCountry\" )) - set ( db . laureates . distinct ( \"bornCountry\" )) print ( countries )","title":"Never from there, but sometimes there at last"},{"location":"primer/04_MongoDB_part2/exercises_solved/#countries-of-affiliation","text":"We saw in the last exercise that countries can be associated with a laureate as their country of birth and as their country of death. For each prize a laureate received, they may also have been affiliated with an institution at the time, located in a country. Determine the number of distinct countries recorded as part of an affiliation for laureates' prizes. Save this as count . # The number of distinct countries of laureate affiliation for prizes count = len ( db . laureates . distinct ( \"prizes.affiliations.country\" )) print ( count )","title":"Countries of affiliation"},{"location":"primer/04_MongoDB_part2/exercises_solved/#triple-plays-mostly-all-around","text":"All prize categories but one \u2013 literature \u2013 have had prizes shared by three or more laureates. Save a filter document criteria that, when passed to db.prizes.distinct , returns all prize categories shared by three or more laureates. That is, \"laureates.2\" must exist for such documents. Save these prize categories as a Python set called triple_play_categories . Confirm via an assertion that \"literature\" is the only prize category with no prizes shared by three or more laureates. # Save a filter for prize documents with three or more laureates criteria = { \"laureates.2\" : { \"$exists\" : True }} # Save the set of distinct prize categories in documents satisfying the criteria triple_play_categories = set ( db . prizes . distinct ( \"category\" , criteria )) # Confirm literature as the only category not satisfying the criteria. assert set ( db . prizes . distinct ( \"category\" )) - triple_play_categories == { \"literature\" }","title":"Triple plays (mostly) all around"},{"location":"primer/04_MongoDB_part2/exercises_solved/#other-sharing-after-world-war-ii","text":"Similar to the example in the lesson, what is the approximate ratio of the number of laureates who won an unshared prize in categories other than physics, chemistry, and medicine after World War II to the number of laureates who won a shared prize in categories other than physics, chemistry, and medicine after World War II? Save an $elemMatch filter unshared to count laureates with unshared prizes in categories other than (\"not in\") [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. Save an $elemMatch filter shared to count laureates with shared (i.e., \"share\" is not \"1\") prizes in categories other than [\"physics\", \"chemistry\", \"medicine\"] in or after 1945. # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : \"1\" , \"year\" : { \"$gt\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : { \"$nin\" : [ \"physics\" , \"chemistry\" , \"medicine\" ]}, \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gt\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio )","title":"Other sharing after World War II"},{"location":"primer/04_MongoDB_part2/exercises_solved/#organizations-and-prizes-over-time","text":"How many organizations won prizes before 1945 versus in or after 1945? - Save a filter before to count organization laureates with prizes won before 1945. Recall that organization status is encoded with the \"gender\" field, and that dot notation is needed to access a laureate's \"year\" field within its \"prizes\" array. - Save a filter in_or_after to count organization laureates with prizes won in or after 1945. # Save a filter for organization laureates with prizes won before 1945 before = { \"gender\" : \"org\" , \"prizes.year\" : { \"$lt\" : \"1945\" } } # Save a filter for organization laureates with prizes won in or after 1945 in_or_after = { \"gender\" : \"org\" , \"prizes.year\" : { \"$gte\" : \"1945\" } } n_before = db . laureates . count_documents ( before ) n_in_or_after = db . laureates . count_documents ( in_or_after ) ratio = n_in_or_after / ( n_in_or_after + n_before ) print ( ratio )","title":"Organizations and prizes over time"},{"location":"primer/04_MongoDB_part2/exercises_solved/#germany-then-and-now","text":"Just as we saw with Poland, there are laureates who were born somewhere that was in Germany at the time but is now not, and others born somewhere that was not in Germany at the time but now is. - Use a regular expression object to filter for laureates with \"Germany\" in their \"bornCountry\" value. # Filter for laureates with \"Germany\" in their \"bornCountry\" value criteria = { \"bornCountry\" : { \"$regex\" : \"Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates with a \"bornCountry\" value starting with \"Germany\". # Filter for laureates with a \"bornCountry\" value starting with \"Germany\" criteria = { \"bornCountry\" : { \"$regex\" : \"^Germany\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what was at the time Germany but is now another country. # Fill in a string value to be sandwiched between the strings \"^\" and \"now\" criteria = { \"bornCountry\" : { \"$regex\" : \"^\" + \"Germany \\(\" + \"now\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria ))) - Use a regular expression object to filter for laureates born in what is now Germany but at the time was another country. # Filter for currently-Germany countries of birth. # Fill in a string value to be sandwiched between the strings \"now\" and \"$\" criteria = { \"bornCountry\" : { \"$regex\" : \"now\" + \" Germany\\)\" + \"$\" }} print ( set ( db . laureates . distinct ( \"bornCountry\" , criteria )))","title":"Germany, then and now"},{"location":"primer/04_MongoDB_part2/exercises_solved/#the-prized-transistor","text":"Three people shared a Nobel prize \"for their researches on semiconductors and their discovery of the transistor effect\". We can filter on \"transistor\" as a substring of a laureate's \"prizes.motivation\" field value to find these laureates. Save a filter criteria that finds laureates with prizes.motivation values containing \"transistor\" as a substring. The substring can appear anywhere within the value, so no anchoring characters are needed. Save to first and last the field names corresponding to a laureate's first name and last name (i.e. \"surname\") so that we can print out the names of these laureates. # Save a filter for laureates with prize motivation values containing \"transistor\" as a substring criteria = { \"prizes.motivation\" : { \"$regex\" : \"transistor\" }} # Save the field names corresponding to a laureate's first name and last name first , last = \"firstname\" , \"surname\" print ([( laureate [ first ], laureate [ last ]) for laureate in db . laureates . find ( criteria )])","title":"The prized transistor"},{"location":"primer/04_MongoDB_part2/exercises_solved/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/exercises_solved/#rounding-up-the-gs-crew","text":"We can use the regular expression operator $regex to find laureates whose initials are G.S. Let's use projection and list comprehension to collect the full names of these laureates by concatenating their first (\"firstname\") and last (\"surname\") names. Fill in the blanks to save a list names of full names (\"firstname\" plus \"surname\") of laureates with initials G.S. (ignoring middles names/initials). You'll need to both filter on names as well as project out the fields required to collect the full names. # Collect a list of full names names = [ \" \" . join ([ doc [ \"firstname\" ], doc [ \"surname\" ]]) for doc in db . laureates . find ( { \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}, { \"firstname\" : 1 , \"surname\" : 1 })] print ( names )","title":"Rounding up the G.S. crew"},{"location":"primer/04_MongoDB_part2/exercises_solved/#sorting-together-mongodb-python","text":"You will print out the names of all physics laureates, with one line printed for each award year, in chronological order. Each line will list laureates for that year in alphabetical order by surname (\"last\" name). I encourage you to print intermediate results and understand the nested structure of prize documents. - Construct a sort specification sort_spec to fetch physics prizes by ascending year. from operator import itemgetter # Sort by ascending year sort_spec = [( \"year\" , 1 )] - Use <collection>.find to construct a cursor that fetches prizes with a \"category\" of \"physics\", sorts by ascending year, and projects the year and first laureate full name ( laureates.firstname and laureates.surname ). You should encounter an error at year 1916 . # Construct a cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - The error is caused by the fact that the Nobel Prize in physics was not awarded in 1916 due to World War I. Supplement the cursor's filter to avoid the error: # Construct a fixed cursor over physics prizes cursor = db . prizes . find ({ \"category\" : \"physics\" , \"laureates\" : { \"$exists\" : True }}, { \"year\" : 1 , \"laureates.firstname\" : 1 , \"laureates.surname\" : 1 }, sort = sort_spec ) for doc in cursor : print ( \" {year} : {first_laureate_firstname} {first_laureate_surname} \" . format ( year = doc [ \"year\" ], first_laureate_firstname = doc [ \"laureates\" ][ 0 ][ \"firstname\" ], first_laureate_surname = doc [ \"laureates\" ][ 0 ][ \"surname\" ])) cursor . rewind () # Rewind cursor to reuse in the next step - Complete the definition of the function names so that, given a prize document, it returns a list of formatted names, sorted by ascending \"surname\", for each of the \"laureates\" in that prize document. # Define a function names() to return a list of formatted names def names ( doc ): formatted_names = [ \" {firstname} {surname} \" . format ( ** laureate ) for laureate in sorted ( doc [ \"laureates\" ], key = itemgetter ( \"surname\" ))] return formatted_names lines = [ \" {year} : {names} \" . format ( year = doc [ \"year\" ], names = \" and \" . join ( names ( doc ))) for doc in cursor ] for line in lines : print ( line )","title":"Sorting together: MongoDB + Python"},{"location":"primer/04_MongoDB_part2/exercises_solved/#gap-years","text":"As we saw above, there have been years for which prizes in one or more of the original categories were not awarded. Sorting first by reverse chronological order and second by alphabetical order of category, collect and format prize documents to produce one formatted entry per year listing categories missing for that year. - Construct a set original_categories of prize categories awarded in 1901. import itertools from operator import itemgetter # Save the set of prize categories awarded in 1901 original_categories = set ( db . prizes . distinct ( \"category\" , { \"year\" : \"1901\" })) print ( original_categories ) - Use <collection>.find to construct a cursor that yields prize documents only for categories in the list of original categories which contain the laureates key and thus were awarded, sorted first by decreasing year and second by increasing category. # Construct a cursor over original-category prizes cursor = db . prizes . find ({ \"category\" : { \"$in\" : list ( original_categories )}, \"laureates\" : { \"$exists\" : True }}, { \"category\" : 1 , \"year\" : 1 }, sort = [( \"year\" , - 1 ), ( \"category\" , 1 )]) - Collect a list not_awarded of entries to be printed, one per line, that displays a year and the categories missing for that year. You will collect \"category\" values for each year and set-subtract them from the original categories. # Collect entries for missing prize categories not_awarded = [] for key , group in itertools . groupby ( cursor , key = itemgetter ( \"year\" )): year_categories = set ( prize [ \"category\" ] for prize in group ) missing = \", \" . join ( sorted ( original_categories - year_categories )) if missing : not_awarded . append ( \" {} : {} \" . format ( key , missing )) for line in not_awarded : print ( line )","title":"Gap years"},{"location":"primer/04_MongoDB_part2/exercises_solved/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/exercises_solved/#an-index-for-high-share-categories","text":"We want to speed up the following operation: db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Confirm that the operation takes approximately 1 ms without an index. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) - Specify a compound index model index_model to pass to db.prizes.create_index . index_model = [( \"laureates.share\" , 1 ), ( \"category\" , 1 )] db . prizes . create_index ( index_model ) - Confirm that the execution time is now below 400 \u00b5s. %% timeit db . prizes . distinct ( \"category\" , { \"laureates.share\" : { \"$gt\" : \"3\" }}) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"An index for high-share categories"},{"location":"primer/04_MongoDB_part2/exercises_solved/#recently-single","text":"A prize might be awarded to a single laureate or to several. For each prize category, report the most recent year that a single laureate -- rather than several -- received a prize in that category. Specify an index model index_model to pass to db.prizes.create_index that speeds up finding prizes by category and sorting results by decreasing year. That is, the model should index first on category (ascending) and second on year (descending). Save a string report for printing the last single-laureate year for each distinct category, one category per line. To do this, for each distinct prize category, find the latest-year prize of that category with a laureate share of \"1\". # Specify an index model for compound sorting index_model = [( \"category\" , 1 ), ( \"year\" , - 1 )] db . prizes . create_index ( index_model ) # Collect the last single-laureate year for each category report = \"\" for category in sorted ( db . prizes . distinct ( \"category\" )): doc = db . prizes . find_one ( { \"category\" : category , \"laureates.share\" : \"1\" }, sort = [( \"year\" , - 1 )] ) report += \" {category} : {year} \\n \" . format ( ** doc ) print ( report ) # Drop the index for consistency db . prizes . drop_index ( index_model )","title":"Recently single?"},{"location":"primer/04_MongoDB_part2/exercises_solved/#born-and-affiliated","text":"Some countries are, for one or more laureates, both their country of birth (\"bornCountry\") and a country of affiliation for one or more of their prizes (\"prizes.affiliations.country\"). You will find the five countries of birth with the highest counts of such laureates. Create an index on country of birth (\"bornCountry\") for db.laureates to ensure efficient gathering of distinct values and counting of documents Complete the skeleton dictionary comprehension to construct n_born_and_affiliated , the count of laureates as described above for each distinct country of birth. from collections import Counter # Ensure an index on country of birth db . laureates . create_index ([( \"bornCountry\" , 1 )]) # Collect a count of laureates for each country of birth n_born_and_affiliated = { country : db . laureates . count_documents ({ \"bornCountry\" : country , \"prizes.affiliations.country\" : country }) for country in db . laureates . distinct ( \"bornCountry\" ) } five_most_common = Counter ( n_born_and_affiliated ) . most_common ( 5 ) print ( five_most_common ) # Drop the index for consistency db . laureates . drop_index ([( \"bornCountry\" , 1 )])","title":"Born and affiliated"},{"location":"primer/04_MongoDB_part2/lesson/","text":"(function() { function addWidgetsRenderer() { var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var scriptElement = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} scriptElement.src = widgetRendererSrc; document.body.appendChild(scriptElement); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); MongoDB Part 2 \u00b6 1: Working with Distinct Values, $elemMatch, and Regex \u00b6 An exceptional laureate \u00b6 from pymongo import MongoClient client = MongoClient () db = client . nobel db . laureates . find_one ({ \"prizes.2\" : { \"$exists\" : True }}) {'_id': ObjectId('5f1f4e418defad6d9f1cd070'), 'id': '482', 'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00', 'died': '0000-00-00', 'gender': 'org', 'prizes': [{'year': '1917', 'category': 'peace', 'share': '1', 'motivation': '\"for the efforts to take care of wounded soldiers and prisoners of war and their families\"', 'affiliations': [[]]}, {'year': '1944', 'category': 'peace', 'share': '1', 'motivation': '\"for the great work it has performed during the war on behalf of humanity\"', 'affiliations': [[]]}, {'year': '1963', 'category': 'peace', 'share': '2', 'motivation': '\"for promoting the principles of the Geneva Convention and cooperation with the UN\"', 'affiliations': [[]]}]} Using .distinct() \u00b6 db . laureates . distinct ( \"gender\" ) ['female', 'male', 'org'] - A convenience method for a common aggregation (like count_documents ) - We will not cover custom aggregations in this lesson, but the aggregate method is powerful. - distinct aggregation is efficient if there is a collection index on the field - We will learn how to create an index later in this lesson - No index needed here: collection fits in memory, has \u2272 1,000 documents All prize categories vs those with multi-winners \u00b6 db . laureates . distinct ( \"prizes.category\" ) ['chemistry', 'economics', 'literature', 'medicine', 'peace', 'physics'] db . laureates . distinct ( \"prizes.category\" ,{ \"prizes.1\" : { \"$exists\" : True }}) ['chemistry', 'peace', 'physics'] Distinct example: Born here, went there \u00b6 In which countries have USA-born laureates had affiliations for their prizes? db . laureates . distinct ( \"prizes.affiliations.country\" ,{ \"bornCountry\" : \"USA\" }) ['Australia', 'Denmark', 'USA', 'United Kingdom'] Enter $elemMatch \u00b6 db . laureates . count_documents ({ \"prizes\" : { \"category\" : \"physics\" , \"share\" : \"1\" } }) 0 Why is the above number zero? db . laureates . count_documents ({ \"prizes.category\" : \"physics\" , \"prizes.share\" : \"1\" }) 48 db . laureates . count_documents ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" } } }) 47 Why are these numbers different? db . laureates . find_one ({ \"firstname\" : \"Marie\" }) {'_id': ObjectId('5f1f4e418defad6d9f1cce9a'), 'id': '6', 'firstname': 'Marie', 'surname': 'Curie', 'born': '1867-11-07', 'died': '1934-07-04', 'bornCountry': 'Russian Empire (now Poland)', 'bornCountryCode': 'PL', 'bornCity': 'Warsaw', 'diedCountry': 'France', 'diedCountryCode': 'FR', 'diedCity': 'Sallanches', 'gender': 'female', 'prizes': [{'year': '1903', 'category': 'physics', 'share': '4', 'motivation': '\"in recognition of the extraordinary services they have rendered by their joint researches on the radiation phenomena discovered by Professor Henri Becquerel\"', 'affiliations': [[]]}, {'year': '1911', 'category': 'chemistry', 'share': '1', 'motivation': '\"in recognition of her services to the advancement of chemistry by the discovery of the elements radium and polonium, by the isolation of radium and the study of the nature and compounds of this remarkable element\"', 'affiliations': [{'name': 'Sorbonne University', 'city': 'Paris', 'country': 'France'}]}]} $elemMatch example: Sharing in physics after World War II \u00b6 What is the approximate ratio of the number of laureates who won an unshared , i.e. {\"share\": \"1\"} , prize in physics after World War II, i.e. {\"year\": {\"$gte\": \"1945\"}} , to the number of laureates who won a shared prize in physics after World War II? # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" , \"year\" : { \"$gte\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gte\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) 0.1232876712328767 Finding a substring with $regex \u00b6 db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"Poland\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)', 'Prussia (now Poland)', 'Russian Empire (now Poland)'] Beginning and ending \u00b6 db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland\" }}) ['Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland \\(now\" }}) ['Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"now Poland\\)$\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Prussia (now Poland)', 'Russian Empire (now Poland)'] Regex example: Glenn, George, and others in the G.S. crew \u00b6 There are two laureates with Berkeley, California as a prize affiliation city that have the initials G.S. - Glenn Seaborg and George Smoot. How many laureates in total have a first name beginning with \"G\" and a surname beginning with \"S\"? db . laureates . count_documents ({ \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}) 10 2: Projection and Sorting \u00b6 What is \"projection\"? \u00b6 reducing data to fewer dimensions Asking certain data to \"speak up\"! Projection in MongoDB \u00b6 When using db.collection.find() , the first argument is the filter and the second is the projection. db . laureates . find ({}, {}) <pymongo.cursor.Cursor at 0x7f8360632850> Since db.collection.find() returns a cursor, we need to make it into a list: list ( db . laureates . find ({},{}))[: 3 ] [{'_id': ObjectId('5f1f4e418defad6d9f1cce95')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce96')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce97')}] An empty projection dictionary by default only displays the entry \"_id\" field. To project out the prizes.affiliation field without the \"_id\" field, we would use a projection equal to {\"prizes.affiliations\": 1, \"_id\": 0} . list ( db . laureates . find ({},{ \"prizes.affiliations\" : 1 , \"_id\" : 0 }))[: 3 ] [{'prizes': [{'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]}, {'prizes': [{'affiliations': [{'name': 'Leiden University', 'city': 'Leiden', 'country': 'the Netherlands'}]}]}, {'prizes': [{'affiliations': [{'name': 'Amsterdam University', 'city': 'Amsterdam', 'country': 'the Netherlands'}]}]}] where the 1 value turns on \"prizes.affiliations\" and the 0 value turns off \"_id\" . Missing fields \u00b6 list ( db . laureates . find ({ \"gender\" : \"org\" }, { \"firstname\" : 1 , \"born\" : 1 , \"_id\" : 0 })) [{'firstname': 'Institute of International Law', 'born': '1873-00-00'}, {'firstname': 'Permanent International Peace Bureau', 'born': '1891-00-00'}, {'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00'}, {'firstname': 'Nansen International Office for Refugees', 'born': '1921-00-00'}, {'firstname': 'Friends Service Council', 'born': '1647-00-00'}, {'firstname': 'American Friends Service Committee', 'born': '1917-00-00'}, {'firstname': 'Office of the United Nations High Commissioner for Refugees', 'born': '1951-00-00'}, {'firstname': 'League of Red Cross Societies', 'born': '1919-00-00'}, {'firstname': \"United Nations Children's Fund\", 'born': '1946-00-00'}, {'firstname': 'International Labour Organization', 'born': '1919-00-00'}, {'firstname': 'Amnesty International', 'born': '1961-00-00'}, {'firstname': 'International Physicians for the Prevention of Nuclear War', 'born': '1980-00-00'}, {'firstname': 'United Nations Peacekeeping Forces', 'born': '1948-00-00'}, {'firstname': 'Pugwash Conferences on Science and World Affairs', 'born': '1957-00-00'}, {'firstname': 'International Campaign to Ban Landmines', 'born': '1992-00-00'}, {'firstname': 'M\u00e9decins Sans Fronti\u00e8res', 'born': '1971-00-00'}, {'firstname': 'United Nations', 'born': '1945-00-00'}, {'firstname': 'International Atomic Energy Agency', 'born': '1957-00-00'}, {'firstname': 'Grameen Bank', 'born': '1976-00-00'}, {'firstname': 'Intergovernmental Panel on Climate Change', 'born': '1988-00-00'}, {'firstname': 'European Union (EU)', 'born': '1952-00-00'}, {'firstname': 'Organisation for the Prohibition of Chemical Weapons', 'born': '1997-00-00'}, {'firstname': 'National Dialogue Quartet '}, {'firstname': 'International Campaign to Abolish Nuclear Weapons (ICAN)', 'born': '2007-00-00'}] Projection example: Shares of the 1963 prize in physics \u00b6 Let's examine the laureates of the 1963 prize in physics and how they split the prize. Here is a query without projection: db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}) How would we fetch the laureates' full names and prize share info? projection = { \"firstname\" : 1 , \"surname\" : 1 , \"prizes.share\" : 1 , \"_id\" : 0 } list ( db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}, projection )) [{'firstname': 'Eugene', 'surname': 'Wigner', 'prizes': [{'share': '2'}]}, {'firstname': 'Maria', 'surname': 'Goeppert Mayer', 'prizes': [{'share': '4'}]}, {'firstname': 'J. Hans D.', 'surname': 'Jensen', 'prizes': [{'share': '4'}]}] Sorting post-query with Python \u00b6 from operator import itemgetter docs = list ( db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 })) docs = sorted ( docs , key = itemgetter ( \"year\" )) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] docs = sorted ( docs , key = itemgetter ( \"year\" ), reverse = True ) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['2019', '2018', '2017', '2016', '2015'] Sorting in-query with MongoDB \u00b6 cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , - 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['2019', '2018', '2017', '2016', '2015'] Primary and secondary sorting \u00b6 for doc in db . prizes . find ( { \"year\" : { \"$gt\" : \"1966\" , \"$lt\" : \"1970\" }}, { \"category\" : 1 , \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 ), ( \"category\" , - 1 )]): print ( doc [ \"year\" ], doc [ \"category\" ]) 1967 physics 1967 peace 1967 medicine 1967 literature 1967 chemistry 1968 physics 1968 peace 1968 medicine 1968 literature 1968 chemistry 1969 physics 1969 peace 1969 medicine 1969 literature 1969 economics 1969 chemistry Sorting example: What the sort? \u00b6 This block prints out the first five projections of a sorted query. What \"sort\" argument fills the blank? docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = ____ )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1954'}, {'year': '1962'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} Primary sorting is ascending by \"prizes.year\" . Secondary sort is descending by \"born\" . Thus, sort= [(\"prizes.year\",1),(\"born\",-1)] . my_sort = [( \"prizes.year\" , 1 ),( \"born\" , - 1 )] docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = my_sort )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1962'}, {'year': '1954'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} 3: Indexing \u00b6 What are indexes? \u00b6 When to use indexes? \u00b6 - Queries with high specificity - Large documents - Large collections Getting index information \u00b6 db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}} Gauging performance before indexing \u00b6 Jupyter Notebook %%timeit magic (same as python -m timeit \"[expression]\" ) %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 577 \u00b5s \u00b1 22.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 5 ms \u00b1 269 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.79 ms \u00b1 400 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) Adding a single-field index \u00b6 - index model: list of (field, direction) pairs. - directions: 1 (ascending) and -1 (descending) db . prizes . create_index ([( \"year\" , 1 )]) 'year_1' db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}, 'year_1': {'v': 2, 'key': [('year', 1)], 'ns': 'nobel.prizes'}} %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 330 \u00b5s \u00b1 12.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 3.89 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.07 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , 1 )]) db . prizes . create_index ([( \"year\" , - 1 )]) 'year_-1' %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.36 ms \u00b1 249 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , - 1 )]) Adding a compound (multiple-field) index \u00b6 - index \"covering\" a query with projection %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 620 \u00b5s \u00b1 3.05 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 435 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) - index \"covering\" a query with projection and sorting %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 698 \u00b5s \u00b1 62.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 504 \u00b5s \u00b1 17.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )])","title":"Advanced MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#mongodb-part-2","text":"","title":"MongoDB Part 2"},{"location":"primer/04_MongoDB_part2/lesson/#1-working-with-distinct-values-elemmatch-and-regex","text":"","title":"1: Working with Distinct Values, $elemMatch, and Regex"},{"location":"primer/04_MongoDB_part2/lesson/#an-exceptional-laureate","text":"from pymongo import MongoClient client = MongoClient () db = client . nobel db . laureates . find_one ({ \"prizes.2\" : { \"$exists\" : True }}) {'_id': ObjectId('5f1f4e418defad6d9f1cd070'), 'id': '482', 'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00', 'died': '0000-00-00', 'gender': 'org', 'prizes': [{'year': '1917', 'category': 'peace', 'share': '1', 'motivation': '\"for the efforts to take care of wounded soldiers and prisoners of war and their families\"', 'affiliations': [[]]}, {'year': '1944', 'category': 'peace', 'share': '1', 'motivation': '\"for the great work it has performed during the war on behalf of humanity\"', 'affiliations': [[]]}, {'year': '1963', 'category': 'peace', 'share': '2', 'motivation': '\"for promoting the principles of the Geneva Convention and cooperation with the UN\"', 'affiliations': [[]]}]}","title":"An exceptional laureate"},{"location":"primer/04_MongoDB_part2/lesson/#using-distinct","text":"db . laureates . distinct ( \"gender\" ) ['female', 'male', 'org'] - A convenience method for a common aggregation (like count_documents ) - We will not cover custom aggregations in this lesson, but the aggregate method is powerful. - distinct aggregation is efficient if there is a collection index on the field - We will learn how to create an index later in this lesson - No index needed here: collection fits in memory, has \u2272 1,000 documents","title":"Using .distinct()"},{"location":"primer/04_MongoDB_part2/lesson/#all-prize-categories-vs-those-with-multi-winners","text":"db . laureates . distinct ( \"prizes.category\" ) ['chemistry', 'economics', 'literature', 'medicine', 'peace', 'physics'] db . laureates . distinct ( \"prizes.category\" ,{ \"prizes.1\" : { \"$exists\" : True }}) ['chemistry', 'peace', 'physics']","title":"All prize categories vs those with multi-winners"},{"location":"primer/04_MongoDB_part2/lesson/#distinct-example-born-here-went-there","text":"In which countries have USA-born laureates had affiliations for their prizes? db . laureates . distinct ( \"prizes.affiliations.country\" ,{ \"bornCountry\" : \"USA\" }) ['Australia', 'Denmark', 'USA', 'United Kingdom']","title":"Distinct example: Born here, went there"},{"location":"primer/04_MongoDB_part2/lesson/#enter-elemmatch","text":"db . laureates . count_documents ({ \"prizes\" : { \"category\" : \"physics\" , \"share\" : \"1\" } }) 0 Why is the above number zero? db . laureates . count_documents ({ \"prizes.category\" : \"physics\" , \"prizes.share\" : \"1\" }) 48 db . laureates . count_documents ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" } } }) 47 Why are these numbers different? db . laureates . find_one ({ \"firstname\" : \"Marie\" }) {'_id': ObjectId('5f1f4e418defad6d9f1cce9a'), 'id': '6', 'firstname': 'Marie', 'surname': 'Curie', 'born': '1867-11-07', 'died': '1934-07-04', 'bornCountry': 'Russian Empire (now Poland)', 'bornCountryCode': 'PL', 'bornCity': 'Warsaw', 'diedCountry': 'France', 'diedCountryCode': 'FR', 'diedCity': 'Sallanches', 'gender': 'female', 'prizes': [{'year': '1903', 'category': 'physics', 'share': '4', 'motivation': '\"in recognition of the extraordinary services they have rendered by their joint researches on the radiation phenomena discovered by Professor Henri Becquerel\"', 'affiliations': [[]]}, {'year': '1911', 'category': 'chemistry', 'share': '1', 'motivation': '\"in recognition of her services to the advancement of chemistry by the discovery of the elements radium and polonium, by the isolation of radium and the study of the nature and compounds of this remarkable element\"', 'affiliations': [{'name': 'Sorbonne University', 'city': 'Paris', 'country': 'France'}]}]}","title":"Enter $elemMatch"},{"location":"primer/04_MongoDB_part2/lesson/#elemmatch-example-sharing-in-physics-after-world-war-ii","text":"What is the approximate ratio of the number of laureates who won an unshared , i.e. {\"share\": \"1\"} , prize in physics after World War II, i.e. {\"year\": {\"$gte\": \"1945\"}} , to the number of laureates who won a shared prize in physics after World War II? # Save a filter for laureates with unshared prizes unshared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : \"1\" , \"year\" : { \"$gte\" : \"1945\" }, }}} # Save a filter for laureates with shared prizes shared = { \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"share\" : { \"$gt\" : \"1\" }, \"year\" : { \"$gte\" : \"1945\" }, }}} ratio = db . laureates . count_documents ( unshared ) / db . laureates . count_documents ( shared ) print ( ratio ) 0.1232876712328767","title":"$elemMatch example: Sharing in physics after World War II"},{"location":"primer/04_MongoDB_part2/lesson/#finding-a-substring-with-regex","text":"db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"Poland\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)', 'Prussia (now Poland)', 'Russian Empire (now Poland)']","title":"Finding a substring with $regex"},{"location":"primer/04_MongoDB_part2/lesson/#beginning-and-ending","text":"db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland\" }}) ['Poland', 'Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"^Poland \\(now\" }}) ['Poland (now Belarus)', 'Poland (now Lithuania)', 'Poland (now Ukraine)'] db . laureates . distinct ( \"bornCountry\" , { \"bornCountry\" : { \"$regex\" : \"now Poland\\)$\" }}) ['Austria-Hungary (now Poland)', 'Free City of Danzig (now Poland)', 'German-occupied Poland (now Poland)', 'Germany (now Poland)', 'Prussia (now Poland)', 'Russian Empire (now Poland)']","title":"Beginning and ending"},{"location":"primer/04_MongoDB_part2/lesson/#regex-example-glenn-george-and-others-in-the-gs-crew","text":"There are two laureates with Berkeley, California as a prize affiliation city that have the initials G.S. - Glenn Seaborg and George Smoot. How many laureates in total have a first name beginning with \"G\" and a surname beginning with \"S\"? db . laureates . count_documents ({ \"firstname\" : { \"$regex\" : \"^G\" }, \"surname\" : { \"$regex\" : \"^S\" }}) 10","title":"Regex example: Glenn, George, and others in the G.S. crew"},{"location":"primer/04_MongoDB_part2/lesson/#2-projection-and-sorting","text":"","title":"2: Projection and Sorting"},{"location":"primer/04_MongoDB_part2/lesson/#what-is-projection","text":"reducing data to fewer dimensions Asking certain data to \"speak up\"!","title":"What is \"projection\"?"},{"location":"primer/04_MongoDB_part2/lesson/#projection-in-mongodb","text":"When using db.collection.find() , the first argument is the filter and the second is the projection. db . laureates . find ({}, {}) <pymongo.cursor.Cursor at 0x7f8360632850> Since db.collection.find() returns a cursor, we need to make it into a list: list ( db . laureates . find ({},{}))[: 3 ] [{'_id': ObjectId('5f1f4e418defad6d9f1cce95')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce96')}, {'_id': ObjectId('5f1f4e418defad6d9f1cce97')}] An empty projection dictionary by default only displays the entry \"_id\" field. To project out the prizes.affiliation field without the \"_id\" field, we would use a projection equal to {\"prizes.affiliations\": 1, \"_id\": 0} . list ( db . laureates . find ({},{ \"prizes.affiliations\" : 1 , \"_id\" : 0 }))[: 3 ] [{'prizes': [{'affiliations': [{'name': 'Munich University', 'city': 'Munich', 'country': 'Germany'}]}]}, {'prizes': [{'affiliations': [{'name': 'Leiden University', 'city': 'Leiden', 'country': 'the Netherlands'}]}]}, {'prizes': [{'affiliations': [{'name': 'Amsterdam University', 'city': 'Amsterdam', 'country': 'the Netherlands'}]}]}] where the 1 value turns on \"prizes.affiliations\" and the 0 value turns off \"_id\" .","title":"Projection in MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#missing-fields","text":"list ( db . laureates . find ({ \"gender\" : \"org\" }, { \"firstname\" : 1 , \"born\" : 1 , \"_id\" : 0 })) [{'firstname': 'Institute of International Law', 'born': '1873-00-00'}, {'firstname': 'Permanent International Peace Bureau', 'born': '1891-00-00'}, {'firstname': 'International Committee of the Red Cross', 'born': '1863-00-00'}, {'firstname': 'Nansen International Office for Refugees', 'born': '1921-00-00'}, {'firstname': 'Friends Service Council', 'born': '1647-00-00'}, {'firstname': 'American Friends Service Committee', 'born': '1917-00-00'}, {'firstname': 'Office of the United Nations High Commissioner for Refugees', 'born': '1951-00-00'}, {'firstname': 'League of Red Cross Societies', 'born': '1919-00-00'}, {'firstname': \"United Nations Children's Fund\", 'born': '1946-00-00'}, {'firstname': 'International Labour Organization', 'born': '1919-00-00'}, {'firstname': 'Amnesty International', 'born': '1961-00-00'}, {'firstname': 'International Physicians for the Prevention of Nuclear War', 'born': '1980-00-00'}, {'firstname': 'United Nations Peacekeeping Forces', 'born': '1948-00-00'}, {'firstname': 'Pugwash Conferences on Science and World Affairs', 'born': '1957-00-00'}, {'firstname': 'International Campaign to Ban Landmines', 'born': '1992-00-00'}, {'firstname': 'M\u00e9decins Sans Fronti\u00e8res', 'born': '1971-00-00'}, {'firstname': 'United Nations', 'born': '1945-00-00'}, {'firstname': 'International Atomic Energy Agency', 'born': '1957-00-00'}, {'firstname': 'Grameen Bank', 'born': '1976-00-00'}, {'firstname': 'Intergovernmental Panel on Climate Change', 'born': '1988-00-00'}, {'firstname': 'European Union (EU)', 'born': '1952-00-00'}, {'firstname': 'Organisation for the Prohibition of Chemical Weapons', 'born': '1997-00-00'}, {'firstname': 'National Dialogue Quartet '}, {'firstname': 'International Campaign to Abolish Nuclear Weapons (ICAN)', 'born': '2007-00-00'}]","title":"Missing fields"},{"location":"primer/04_MongoDB_part2/lesson/#projection-example-shares-of-the-1963-prize-in-physics","text":"Let's examine the laureates of the 1963 prize in physics and how they split the prize. Here is a query without projection: db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}) How would we fetch the laureates' full names and prize share info? projection = { \"firstname\" : 1 , \"surname\" : 1 , \"prizes.share\" : 1 , \"_id\" : 0 } list ( db . laureates . find ({ \"prizes\" : { \"$elemMatch\" : { \"category\" : \"physics\" , \"year\" : \"1963\" }}}, projection )) [{'firstname': 'Eugene', 'surname': 'Wigner', 'prizes': [{'share': '2'}]}, {'firstname': 'Maria', 'surname': 'Goeppert Mayer', 'prizes': [{'share': '4'}]}, {'firstname': 'J. Hans D.', 'surname': 'Jensen', 'prizes': [{'share': '4'}]}]","title":"Projection example: Shares of the 1963 prize in physics"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-post-query-with-python","text":"from operator import itemgetter docs = list ( db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 })) docs = sorted ( docs , key = itemgetter ( \"year\" )) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] docs = sorted ( docs , key = itemgetter ( \"year\" ), reverse = True ) print ([ doc [ \"year\" ] for doc in docs ][: 5 ]) ['2019', '2018', '2017', '2016', '2015']","title":"Sorting post-query with Python"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-in-query-with-mongodb","text":"cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['1901', '1902', '1903', '1904', '1905'] cursor = db . prizes . find ({ \"category\" : \"physics\" }, { \"year\" : 1 }, sort = [( \"year\" , - 1 )]) print ([ doc [ \"year\" ] for doc in cursor ][: 5 ]) ['2019', '2018', '2017', '2016', '2015']","title":"Sorting in-query with MongoDB"},{"location":"primer/04_MongoDB_part2/lesson/#primary-and-secondary-sorting","text":"for doc in db . prizes . find ( { \"year\" : { \"$gt\" : \"1966\" , \"$lt\" : \"1970\" }}, { \"category\" : 1 , \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 ), ( \"category\" , - 1 )]): print ( doc [ \"year\" ], doc [ \"category\" ]) 1967 physics 1967 peace 1967 medicine 1967 literature 1967 chemistry 1968 physics 1968 peace 1968 medicine 1968 literature 1968 chemistry 1969 physics 1969 peace 1969 medicine 1969 literature 1969 economics 1969 chemistry","title":"Primary and secondary sorting"},{"location":"primer/04_MongoDB_part2/lesson/#sorting-example-what-the-sort","text":"This block prints out the first five projections of a sorted query. What \"sort\" argument fills the blank? docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = ____ )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1954'}, {'year': '1962'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]} Primary sorting is ascending by \"prizes.year\" . Secondary sort is descending by \"born\" . Thus, sort= [(\"prizes.year\",1),(\"born\",-1)] . my_sort = [( \"prizes.year\" , 1 ),( \"born\" , - 1 )] docs = list ( db . laureates . find ( { \"born\" : { \"$gte\" : \"1900\" }, \"prizes.year\" : { \"$gte\" : \"1954\" }, \"gender\" :{ \"$in\" :[ \"male\" , \"female\" ]}}, { \"born\" : 1 , \"prizes.year\" : 1 , \"_id\" : 0 }, sort = my_sort )) for doc in docs [: 5 ]: print ( doc ) {'born': '1916-08-25', 'prizes': [{'year': '1954'}]} {'born': '1915-06-15', 'prizes': [{'year': '1954'}]} {'born': '1901-02-28', 'prizes': [{'year': '1962'}, {'year': '1954'}]} {'born': '1913-07-12', 'prizes': [{'year': '1955'}]} {'born': '1911-01-26', 'prizes': [{'year': '1955'}]}","title":"Sorting example: What the sort?"},{"location":"primer/04_MongoDB_part2/lesson/#3-indexing","text":"","title":"3: Indexing"},{"location":"primer/04_MongoDB_part2/lesson/#what-are-indexes","text":"","title":"What are indexes?"},{"location":"primer/04_MongoDB_part2/lesson/#when-to-use-indexes","text":"- Queries with high specificity - Large documents - Large collections","title":"When to use indexes?"},{"location":"primer/04_MongoDB_part2/lesson/#getting-index-information","text":"db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}}","title":"Getting index information"},{"location":"primer/04_MongoDB_part2/lesson/#gauging-performance-before-indexing","text":"Jupyter Notebook %%timeit magic (same as python -m timeit \"[expression]\" ) %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 577 \u00b5s \u00b1 22.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 5 ms \u00b1 269 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.79 ms \u00b1 400 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each)","title":"Gauging performance before indexing"},{"location":"primer/04_MongoDB_part2/lesson/#adding-a-single-field-index","text":"- index model: list of (field, direction) pairs. - directions: 1 (ascending) and -1 (descending) db . prizes . create_index ([( \"year\" , 1 )]) 'year_1' db . prizes . index_information () {'_id_': {'v': 2, 'key': [('_id', 1)], 'ns': 'nobel.prizes'}, 'year_1': {'v': 2, 'key': [('year', 1)], 'ns': 'nobel.prizes'}} %% timeit docs = list ( db . prizes . find ({ \"year\" : \"1901\" })) 330 \u00b5s \u00b1 12.1 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , 1 )])) 3.89 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.07 ms \u00b1 122 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , 1 )]) db . prizes . create_index ([( \"year\" , - 1 )]) 'year_-1' %% timeit docs = list ( db . prizes . find ({}, sort = [( \"year\" , - 1 )])) 4.36 ms \u00b1 249 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100 loops each) db . prizes . drop_index ([( \"year\" , - 1 )])","title":"Adding a single-field index"},{"location":"primer/04_MongoDB_part2/lesson/#adding-a-compound-multiple-field-index","text":"- index \"covering\" a query with projection %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 620 \u00b5s \u00b1 3.05 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit list ( db . prizes . find ({ \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 })) 435 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) - index \"covering\" a query with projection and sorting %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 698 \u00b5s \u00b1 62.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . create_index ([( \"category\" , 1 ), ( \"year\" , 1 )]) 'category_1_year_1' %% timeit db . prizes . find_one ( { \"category\" : \"economics\" }, { \"year\" : 1 , \"_id\" : 0 }, sort = [( \"year\" , 1 )] ) 504 \u00b5s \u00b1 17.7 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each) db . prizes . drop_index ([( \"category\" , 1 ), ( \"year\" , 1 )])","title":"Adding a compound (multiple-field) index"}]}